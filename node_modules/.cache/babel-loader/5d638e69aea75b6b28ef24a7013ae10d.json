{"ast":null,"code":"/*!\n * proxy-addr\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = proxyaddr;\nmodule.exports.all = alladdrs;\nmodule.exports.compile = compile;\n/**\n * Module dependencies.\n * @private\n */\n\nvar forwarded = require('forwarded');\n\nvar ipaddr = require('ipaddr.js');\n/**\n * Variables.\n * @private\n */\n\n\nvar DIGIT_REGEXP = /^[0-9]+$/;\nvar isip = ipaddr.isValid;\nvar parseip = ipaddr.parse;\n/**\n * Pre-defined IP ranges.\n * @private\n */\n\nvar IP_RANGES = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n};\n/**\n * Get all addresses in the request, optionally stopping\n * at the first untrusted.\n *\n * @param {Object} request\n * @param {Function|Array|String} [trust]\n * @public\n */\n\nfunction alladdrs(req, trust) {\n  // get addresses\n  var addrs = forwarded(req);\n\n  if (!trust) {\n    // Return all addresses\n    return addrs;\n  }\n\n  if (typeof trust !== 'function') {\n    trust = compile(trust);\n  }\n\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue;\n    addrs.length = i + 1;\n  }\n\n  return addrs;\n}\n/**\n * Compile argument into trust function.\n *\n * @param {Array|String} val\n * @private\n */\n\n\nfunction compile(val) {\n  if (!val) {\n    throw new TypeError('argument is required');\n  }\n\n  var trust;\n\n  if (typeof val === 'string') {\n    trust = [val];\n  } else if (Array.isArray(val)) {\n    trust = val.slice();\n  } else {\n    throw new TypeError('unsupported trust argument');\n  }\n\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i];\n\n    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {\n      continue;\n    } // Splice in pre-defined range\n\n\n    val = IP_RANGES[val];\n    trust.splice.apply(trust, [i, 1].concat(val));\n    i += val.length - 1;\n  }\n\n  return compileTrust(compileRangeSubnets(trust));\n}\n/**\n * Compile `arr` elements into range subnets.\n *\n * @param {Array} arr\n * @private\n */\n\n\nfunction compileRangeSubnets(arr) {\n  var rangeSubnets = new Array(arr.length);\n\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = parseipNotation(arr[i]);\n  }\n\n  return rangeSubnets;\n}\n/**\n * Compile range subnet array into trust function.\n *\n * @param {Array} rangeSubnets\n * @private\n */\n\n\nfunction compileTrust(rangeSubnets) {\n  // Return optimized function based on length\n  var len = rangeSubnets.length;\n  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);\n}\n/**\n * Parse IP notation string into range subnet.\n *\n * @param {String} note\n * @private\n */\n\n\nfunction parseipNotation(note) {\n  var pos = note.lastIndexOf('/');\n  var str = pos !== -1 ? note.substring(0, pos) : note;\n\n  if (!isip(str)) {\n    throw new TypeError('invalid IP address: ' + str);\n  }\n\n  var ip = parseip(str);\n\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    // Store as IPv4\n    ip = ip.toIPv4Address();\n  }\n\n  var max = ip.kind() === 'ipv6' ? 128 : 32;\n  var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;\n\n  if (range === null) {\n    range = max;\n  } else if (DIGIT_REGEXP.test(range)) {\n    range = parseInt(range, 10);\n  } else if (ip.kind() === 'ipv4' && isip(range)) {\n    range = parseNetmask(range);\n  } else {\n    range = null;\n  }\n\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note);\n  }\n\n  return [ip, range];\n}\n/**\n * Parse netmask string into CIDR range.\n *\n * @param {String} netmask\n * @private\n */\n\n\nfunction parseNetmask(netmask) {\n  var ip = parseip(netmask);\n  var kind = ip.kind();\n  return kind === 'ipv4' ? ip.prefixLengthFromSubnetMask() : null;\n}\n/**\n * Determine address of proxied request.\n *\n * @param {Object} request\n * @param {Function|Array|String} trust\n * @public\n */\n\n\nfunction proxyaddr(req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required');\n  }\n\n  if (!trust) {\n    throw new TypeError('trust argument is required');\n  }\n\n  var addrs = alladdrs(req, trust);\n  var addr = addrs[addrs.length - 1];\n  return addr;\n}\n/**\n * Static trust function to trust nothing.\n *\n * @private\n */\n\n\nfunction trustNone() {\n  return false;\n}\n/**\n * Compile trust function for multiple subnets.\n *\n * @param {Array} subnets\n * @private\n */\n\n\nfunction trustMulti(subnets) {\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n    var ip = parseip(addr);\n    var ipconv;\n    var kind = ip.kind();\n\n    for (var i = 0; i < subnets.length; i++) {\n      var subnet = subnets[i];\n      var subnetip = subnet[0];\n      var subnetkind = subnetip.kind();\n      var subnetrange = subnet[1];\n      var trusted = ip;\n\n      if (kind !== subnetkind) {\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\n          // Incompatible IP addresses\n          continue;\n        }\n\n        if (!ipconv) {\n          // Convert IP to match subnet IP kind\n          ipconv = subnetkind === 'ipv4' ? ip.toIPv4Address() : ip.toIPv4MappedAddress();\n        }\n\n        trusted = ipconv;\n      }\n\n      if (trusted.match(subnetip, subnetrange)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n/**\n * Compile trust function for single subnet.\n *\n * @param {Object} subnet\n * @private\n */\n\n\nfunction trustSingle(subnet) {\n  var subnetip = subnet[0];\n  var subnetkind = subnetip.kind();\n  var subnetisipv4 = subnetkind === 'ipv4';\n  var subnetrange = subnet[1];\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n    var ip = parseip(addr);\n    var kind = ip.kind();\n\n    if (kind !== subnetkind) {\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\n        // Incompatible IP addresses\n        return false;\n      } // Convert IP to match subnet IP kind\n\n\n      ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();\n    }\n\n    return ip.match(subnetip, subnetrange);\n  };\n}","map":{"version":3,"sources":["/Users/dhruv/Sneaks/sneaks-website/node_modules/proxy-addr/index.js"],"names":["module","exports","proxyaddr","all","alladdrs","compile","forwarded","require","ipaddr","DIGIT_REGEXP","isip","isValid","parseip","parse","IP_RANGES","linklocal","loopback","uniquelocal","req","trust","addrs","i","length","val","TypeError","Array","isArray","slice","Object","prototype","hasOwnProperty","call","splice","apply","concat","compileTrust","compileRangeSubnets","arr","rangeSubnets","parseipNotation","len","trustNone","trustSingle","trustMulti","note","pos","lastIndexOf","str","substring","ip","kind","isIPv4MappedAddress","toIPv4Address","max","range","test","parseInt","parseNetmask","netmask","prefixLengthFromSubnetMask","addr","subnets","ipconv","subnet","subnetip","subnetkind","subnetrange","trusted","toIPv4MappedAddress","match","subnetisipv4"],"mappings":"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","sourcesContent":["/*!\n * proxy-addr\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = proxyaddr\nmodule.exports.all = alladdrs\nmodule.exports.compile = compile\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar forwarded = require('forwarded')\nvar ipaddr = require('ipaddr.js')\n\n/**\n * Variables.\n * @private\n */\n\nvar DIGIT_REGEXP = /^[0-9]+$/\nvar isip = ipaddr.isValid\nvar parseip = ipaddr.parse\n\n/**\n * Pre-defined IP ranges.\n * @private\n */\n\nvar IP_RANGES = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n}\n\n/**\n * Get all addresses in the request, optionally stopping\n * at the first untrusted.\n *\n * @param {Object} request\n * @param {Function|Array|String} [trust]\n * @public\n */\n\nfunction alladdrs (req, trust) {\n  // get addresses\n  var addrs = forwarded(req)\n\n  if (!trust) {\n    // Return all addresses\n    return addrs\n  }\n\n  if (typeof trust !== 'function') {\n    trust = compile(trust)\n  }\n\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue\n\n    addrs.length = i + 1\n  }\n\n  return addrs\n}\n\n/**\n * Compile argument into trust function.\n *\n * @param {Array|String} val\n * @private\n */\n\nfunction compile (val) {\n  if (!val) {\n    throw new TypeError('argument is required')\n  }\n\n  var trust\n\n  if (typeof val === 'string') {\n    trust = [val]\n  } else if (Array.isArray(val)) {\n    trust = val.slice()\n  } else {\n    throw new TypeError('unsupported trust argument')\n  }\n\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i]\n\n    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {\n      continue\n    }\n\n    // Splice in pre-defined range\n    val = IP_RANGES[val]\n    trust.splice.apply(trust, [i, 1].concat(val))\n    i += val.length - 1\n  }\n\n  return compileTrust(compileRangeSubnets(trust))\n}\n\n/**\n * Compile `arr` elements into range subnets.\n *\n * @param {Array} arr\n * @private\n */\n\nfunction compileRangeSubnets (arr) {\n  var rangeSubnets = new Array(arr.length)\n\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = parseipNotation(arr[i])\n  }\n\n  return rangeSubnets\n}\n\n/**\n * Compile range subnet array into trust function.\n *\n * @param {Array} rangeSubnets\n * @private\n */\n\nfunction compileTrust (rangeSubnets) {\n  // Return optimized function based on length\n  var len = rangeSubnets.length\n  return len === 0\n    ? trustNone\n    : len === 1\n      ? trustSingle(rangeSubnets[0])\n      : trustMulti(rangeSubnets)\n}\n\n/**\n * Parse IP notation string into range subnet.\n *\n * @param {String} note\n * @private\n */\n\nfunction parseipNotation (note) {\n  var pos = note.lastIndexOf('/')\n  var str = pos !== -1\n    ? note.substring(0, pos)\n    : note\n\n  if (!isip(str)) {\n    throw new TypeError('invalid IP address: ' + str)\n  }\n\n  var ip = parseip(str)\n\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    // Store as IPv4\n    ip = ip.toIPv4Address()\n  }\n\n  var max = ip.kind() === 'ipv6'\n    ? 128\n    : 32\n\n  var range = pos !== -1\n    ? note.substring(pos + 1, note.length)\n    : null\n\n  if (range === null) {\n    range = max\n  } else if (DIGIT_REGEXP.test(range)) {\n    range = parseInt(range, 10)\n  } else if (ip.kind() === 'ipv4' && isip(range)) {\n    range = parseNetmask(range)\n  } else {\n    range = null\n  }\n\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note)\n  }\n\n  return [ip, range]\n}\n\n/**\n * Parse netmask string into CIDR range.\n *\n * @param {String} netmask\n * @private\n */\n\nfunction parseNetmask (netmask) {\n  var ip = parseip(netmask)\n  var kind = ip.kind()\n\n  return kind === 'ipv4'\n    ? ip.prefixLengthFromSubnetMask()\n    : null\n}\n\n/**\n * Determine address of proxied request.\n *\n * @param {Object} request\n * @param {Function|Array|String} trust\n * @public\n */\n\nfunction proxyaddr (req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required')\n  }\n\n  if (!trust) {\n    throw new TypeError('trust argument is required')\n  }\n\n  var addrs = alladdrs(req, trust)\n  var addr = addrs[addrs.length - 1]\n\n  return addr\n}\n\n/**\n * Static trust function to trust nothing.\n *\n * @private\n */\n\nfunction trustNone () {\n  return false\n}\n\n/**\n * Compile trust function for multiple subnets.\n *\n * @param {Array} subnets\n * @private\n */\n\nfunction trustMulti (subnets) {\n  return function trust (addr) {\n    if (!isip(addr)) return false\n\n    var ip = parseip(addr)\n    var ipconv\n    var kind = ip.kind()\n\n    for (var i = 0; i < subnets.length; i++) {\n      var subnet = subnets[i]\n      var subnetip = subnet[0]\n      var subnetkind = subnetip.kind()\n      var subnetrange = subnet[1]\n      var trusted = ip\n\n      if (kind !== subnetkind) {\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\n          // Incompatible IP addresses\n          continue\n        }\n\n        if (!ipconv) {\n          // Convert IP to match subnet IP kind\n          ipconv = subnetkind === 'ipv4'\n            ? ip.toIPv4Address()\n            : ip.toIPv4MappedAddress()\n        }\n\n        trusted = ipconv\n      }\n\n      if (trusted.match(subnetip, subnetrange)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Compile trust function for single subnet.\n *\n * @param {Object} subnet\n * @private\n */\n\nfunction trustSingle (subnet) {\n  var subnetip = subnet[0]\n  var subnetkind = subnetip.kind()\n  var subnetisipv4 = subnetkind === 'ipv4'\n  var subnetrange = subnet[1]\n\n  return function trust (addr) {\n    if (!isip(addr)) return false\n\n    var ip = parseip(addr)\n    var kind = ip.kind()\n\n    if (kind !== subnetkind) {\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\n        // Incompatible IP addresses\n        return false\n      }\n\n      // Convert IP to match subnet IP kind\n      ip = subnetisipv4\n        ? ip.toIPv4Address()\n        : ip.toIPv4MappedAddress()\n    }\n\n    return ip.match(subnetip, subnetrange)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
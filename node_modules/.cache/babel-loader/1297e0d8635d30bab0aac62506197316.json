{"ast":null,"code":"/*!\n * accepts\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n/**\n * Module dependencies.\n * @private\n */\n\nvar Negotiator = require('negotiator');\n\nvar mime = require('mime-types');\n/**\n * Module exports.\n * @public\n */\n\n\nmodule.exports = Accepts;\n/**\n * Create a new Accepts object for the given req.\n *\n * @param {object} req\n * @public\n */\n\nfunction Accepts(req) {\n  if (!(this instanceof Accepts)) {\n    return new Accepts(req);\n  }\n\n  this.headers = req.headers;\n  this.negotiator = new Negotiator(req);\n}\n/**\n * Check if the given `type(s)` is acceptable, returning\n * the best match when true, otherwise `undefined`, in which\n * case you should respond with 406 \"Not Acceptable\".\n *\n * The `type` value may be a single mime type string\n * such as \"application/json\", the extension name\n * such as \"json\" or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n * or array is given the _best_ match, if any is returned.\n *\n * Examples:\n *\n *     // Accept: text/html\n *     this.types('html');\n *     // => \"html\"\n *\n *     // Accept: text/*, application/json\n *     this.types('html');\n *     // => \"html\"\n *     this.types('text/html');\n *     // => \"text/html\"\n *     this.types('json', 'text');\n *     // => \"json\"\n *     this.types('application/json');\n *     // => \"application/json\"\n *\n *     // Accept: text/*, application/json\n *     this.types('image/png');\n *     this.types('png');\n *     // => undefined\n *\n *     // Accept: text/*;q=.5, application/json\n *     this.types(['html', 'json']);\n *     this.types('html', 'json');\n *     // => \"json\"\n *\n * @param {String|Array} types...\n * @return {String|Array|Boolean}\n * @public\n */\n\n\nAccepts.prototype.type = Accepts.prototype.types = function (types_) {\n  var types = types_; // support flattened arguments\n\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length);\n\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i];\n    }\n  } // no types, return all requested types\n\n\n  if (!types || types.length === 0) {\n    return this.negotiator.mediaTypes();\n  } // no accept header, return first given type\n\n\n  if (!this.headers.accept) {\n    return types[0];\n  }\n\n  var mimes = types.map(extToMime);\n  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));\n  var first = accepts[0];\n  return first ? types[mimes.indexOf(first)] : false;\n};\n/**\n * Return accepted encodings or best fit based on `encodings`.\n *\n * Given `Accept-Encoding: gzip, deflate`\n * an array sorted by quality is returned:\n *\n *     ['gzip', 'deflate']\n *\n * @param {String|Array} encodings...\n * @return {String|Array}\n * @public\n */\n\n\nAccepts.prototype.encoding = Accepts.prototype.encodings = function (encodings_) {\n  var encodings = encodings_; // support flattened arguments\n\n  if (encodings && !Array.isArray(encodings)) {\n    encodings = new Array(arguments.length);\n\n    for (var i = 0; i < encodings.length; i++) {\n      encodings[i] = arguments[i];\n    }\n  } // no encodings, return all requested encodings\n\n\n  if (!encodings || encodings.length === 0) {\n    return this.negotiator.encodings();\n  }\n\n  return this.negotiator.encodings(encodings)[0] || false;\n};\n/**\n * Return accepted charsets or best fit based on `charsets`.\n *\n * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`\n * an array sorted by quality is returned:\n *\n *     ['utf-8', 'utf-7', 'iso-8859-1']\n *\n * @param {String|Array} charsets...\n * @return {String|Array}\n * @public\n */\n\n\nAccepts.prototype.charset = Accepts.prototype.charsets = function (charsets_) {\n  var charsets = charsets_; // support flattened arguments\n\n  if (charsets && !Array.isArray(charsets)) {\n    charsets = new Array(arguments.length);\n\n    for (var i = 0; i < charsets.length; i++) {\n      charsets[i] = arguments[i];\n    }\n  } // no charsets, return all requested charsets\n\n\n  if (!charsets || charsets.length === 0) {\n    return this.negotiator.charsets();\n  }\n\n  return this.negotiator.charsets(charsets)[0] || false;\n};\n/**\n * Return accepted languages or best fit based on `langs`.\n *\n * Given `Accept-Language: en;q=0.8, es, pt`\n * an array sorted by quality is returned:\n *\n *     ['es', 'pt', 'en']\n *\n * @param {String|Array} langs...\n * @return {Array|String}\n * @public\n */\n\n\nAccepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function (languages_) {\n  var languages = languages_; // support flattened arguments\n\n  if (languages && !Array.isArray(languages)) {\n    languages = new Array(arguments.length);\n\n    for (var i = 0; i < languages.length; i++) {\n      languages[i] = arguments[i];\n    }\n  } // no languages, return all requested languages\n\n\n  if (!languages || languages.length === 0) {\n    return this.negotiator.languages();\n  }\n\n  return this.negotiator.languages(languages)[0] || false;\n};\n/**\n * Convert extnames to mime.\n *\n * @param {String} type\n * @return {String}\n * @private\n */\n\n\nfunction extToMime(type) {\n  return type.indexOf('/') === -1 ? mime.lookup(type) : type;\n}\n/**\n * Check if mime is valid.\n *\n * @param {String} type\n * @return {String}\n * @private\n */\n\n\nfunction validMime(type) {\n  return typeof type === 'string';\n}","map":{"version":3,"sources":["/Users/dhruv/Sneaks/sneaks-website/node_modules/accepts/index.js"],"names":["Negotiator","require","mime","module","exports","Accepts","req","headers","negotiator","prototype","type","types","types_","Array","isArray","arguments","length","i","mediaTypes","accept","mimes","map","extToMime","accepts","filter","validMime","first","indexOf","encoding","encodings","encodings_","charset","charsets","charsets_","lang","langs","language","languages","languages_","lookup"],"mappings":"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","sourcesContent":["/*!\n * accepts\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Negotiator = require('negotiator')\nvar mime = require('mime-types')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = Accepts\n\n/**\n * Create a new Accepts object for the given req.\n *\n * @param {object} req\n * @public\n */\n\nfunction Accepts (req) {\n  if (!(this instanceof Accepts)) {\n    return new Accepts(req)\n  }\n\n  this.headers = req.headers\n  this.negotiator = new Negotiator(req)\n}\n\n/**\n * Check if the given `type(s)` is acceptable, returning\n * the best match when true, otherwise `undefined`, in which\n * case you should respond with 406 \"Not Acceptable\".\n *\n * The `type` value may be a single mime type string\n * such as \"application/json\", the extension name\n * such as \"json\" or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n * or array is given the _best_ match, if any is returned.\n *\n * Examples:\n *\n *     // Accept: text/html\n *     this.types('html');\n *     // => \"html\"\n *\n *     // Accept: text/*, application/json\n *     this.types('html');\n *     // => \"html\"\n *     this.types('text/html');\n *     // => \"text/html\"\n *     this.types('json', 'text');\n *     // => \"json\"\n *     this.types('application/json');\n *     // => \"application/json\"\n *\n *     // Accept: text/*, application/json\n *     this.types('image/png');\n *     this.types('png');\n *     // => undefined\n *\n *     // Accept: text/*;q=.5, application/json\n *     this.types(['html', 'json']);\n *     this.types('html', 'json');\n *     // => \"json\"\n *\n * @param {String|Array} types...\n * @return {String|Array|Boolean}\n * @public\n */\n\nAccepts.prototype.type =\nAccepts.prototype.types = function (types_) {\n  var types = types_\n\n  // support flattened arguments\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length)\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i]\n    }\n  }\n\n  // no types, return all requested types\n  if (!types || types.length === 0) {\n    return this.negotiator.mediaTypes()\n  }\n\n  // no accept header, return first given type\n  if (!this.headers.accept) {\n    return types[0]\n  }\n\n  var mimes = types.map(extToMime)\n  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime))\n  var first = accepts[0]\n\n  return first\n    ? types[mimes.indexOf(first)]\n    : false\n}\n\n/**\n * Return accepted encodings or best fit based on `encodings`.\n *\n * Given `Accept-Encoding: gzip, deflate`\n * an array sorted by quality is returned:\n *\n *     ['gzip', 'deflate']\n *\n * @param {String|Array} encodings...\n * @return {String|Array}\n * @public\n */\n\nAccepts.prototype.encoding =\nAccepts.prototype.encodings = function (encodings_) {\n  var encodings = encodings_\n\n  // support flattened arguments\n  if (encodings && !Array.isArray(encodings)) {\n    encodings = new Array(arguments.length)\n    for (var i = 0; i < encodings.length; i++) {\n      encodings[i] = arguments[i]\n    }\n  }\n\n  // no encodings, return all requested encodings\n  if (!encodings || encodings.length === 0) {\n    return this.negotiator.encodings()\n  }\n\n  return this.negotiator.encodings(encodings)[0] || false\n}\n\n/**\n * Return accepted charsets or best fit based on `charsets`.\n *\n * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`\n * an array sorted by quality is returned:\n *\n *     ['utf-8', 'utf-7', 'iso-8859-1']\n *\n * @param {String|Array} charsets...\n * @return {String|Array}\n * @public\n */\n\nAccepts.prototype.charset =\nAccepts.prototype.charsets = function (charsets_) {\n  var charsets = charsets_\n\n  // support flattened arguments\n  if (charsets && !Array.isArray(charsets)) {\n    charsets = new Array(arguments.length)\n    for (var i = 0; i < charsets.length; i++) {\n      charsets[i] = arguments[i]\n    }\n  }\n\n  // no charsets, return all requested charsets\n  if (!charsets || charsets.length === 0) {\n    return this.negotiator.charsets()\n  }\n\n  return this.negotiator.charsets(charsets)[0] || false\n}\n\n/**\n * Return accepted languages or best fit based on `langs`.\n *\n * Given `Accept-Language: en;q=0.8, es, pt`\n * an array sorted by quality is returned:\n *\n *     ['es', 'pt', 'en']\n *\n * @param {String|Array} langs...\n * @return {Array|String}\n * @public\n */\n\nAccepts.prototype.lang =\nAccepts.prototype.langs =\nAccepts.prototype.language =\nAccepts.prototype.languages = function (languages_) {\n  var languages = languages_\n\n  // support flattened arguments\n  if (languages && !Array.isArray(languages)) {\n    languages = new Array(arguments.length)\n    for (var i = 0; i < languages.length; i++) {\n      languages[i] = arguments[i]\n    }\n  }\n\n  // no languages, return all requested languages\n  if (!languages || languages.length === 0) {\n    return this.negotiator.languages()\n  }\n\n  return this.negotiator.languages(languages)[0] || false\n}\n\n/**\n * Convert extnames to mime.\n *\n * @param {String} type\n * @return {String}\n * @private\n */\n\nfunction extToMime (type) {\n  return type.indexOf('/') === -1\n    ? mime.lookup(type)\n    : type\n}\n\n/**\n * Check if mime is valid.\n *\n * @param {String} type\n * @return {String}\n * @private\n */\n\nfunction validMime (type) {\n  return typeof type === 'string'\n}\n"]},"metadata":{},"sourceType":"script"}
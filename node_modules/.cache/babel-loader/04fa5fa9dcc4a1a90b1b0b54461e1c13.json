{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst tls = require('tls');\n\nconst http2 = require('http2');\n\nconst QuickLRU = require('quick-lru');\n\nconst kCurrentStreamsCount = Symbol('currentStreamsCount');\nconst kRequest = Symbol('request');\nconst kOriginSet = Symbol('cachedOriginSet');\nconst kGracefullyClosing = Symbol('gracefullyClosing');\nconst nameKeys = [// `http2.connect()` options\n'maxDeflateDynamicTableSize', 'maxSessionMemory', 'maxHeaderListPairs', 'maxOutstandingPings', 'maxReservedRemoteStreams', 'maxSendHeaderBlockLength', 'paddingStrategy', // `tls.connect()` options\n'localAddress', 'path', 'rejectUnauthorized', 'minDHSize', // `tls.createSecureContext()` options\n'ca', 'cert', 'clientCertEngine', 'ciphers', 'key', 'pfx', 'servername', 'minVersion', 'maxVersion', 'secureProtocol', 'crl', 'honorCipherOrder', 'ecdhCurve', 'dhparam', 'secureOptions', 'sessionIdContext'];\n\nconst getSortedIndex = (array, value, compare) => {\n  let low = 0;\n  let high = array.length;\n\n  while (low < high) {\n    const mid = low + high >>> 1;\n    /* istanbul ignore next */\n\n    if (compare(array[mid], value)) {\n      // This never gets called because we use descending sort. Better to have this anyway.\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n\n  return low;\n};\n\nconst compareSessions = (a, b) => {\n  return a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;\n}; // See https://tools.ietf.org/html/rfc8336\n\n\nconst closeCoveredSessions = (where, session) => {\n  // Clients SHOULD NOT emit new requests on any connection whose Origin\n  // Set is a proper subset of another connection's Origin Set, and they\n  // SHOULD close it once all outstanding requests are satisfied.\n  for (const coveredSession of where) {\n    if ( // The set is a proper subset when its length is less than the other set.\n    coveredSession[kOriginSet].length < session[kOriginSet].length && // And the other set includes all elements of the subset.\n    coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) && // Makes sure that the session can handle all requests from the covered session.\n    coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {\n      // This allows pending requests to finish and prevents making new requests.\n      gracefullyClose(coveredSession);\n    }\n  }\n}; // This is basically inverted `closeCoveredSessions(...)`.\n\n\nconst closeSessionIfCovered = (where, coveredSession) => {\n  for (const session of where) {\n    if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {\n      gracefullyClose(coveredSession);\n    }\n  }\n};\n\nconst getSessions = ({\n  agent,\n  isFree\n}) => {\n  const result = {}; // eslint-disable-next-line guard-for-in\n\n  for (const normalizedOptions in agent.sessions) {\n    const sessions = agent.sessions[normalizedOptions];\n    const filtered = sessions.filter(session => {\n      const result = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n      return isFree ? result : !result;\n    });\n\n    if (filtered.length !== 0) {\n      result[normalizedOptions] = filtered;\n    }\n  }\n\n  return result;\n};\n\nconst gracefullyClose = session => {\n  session[kGracefullyClosing] = true;\n\n  if (session[kCurrentStreamsCount] === 0) {\n    session.close();\n  }\n};\n\nclass Agent extends EventEmitter {\n  constructor({\n    timeout = 60000,\n    maxSessions = Infinity,\n    maxFreeSessions = 10,\n    maxCachedTlsSessions = 100\n  } = {}) {\n    super(); // A session is considered busy when its current streams count\n    // is equal to or greater than the `maxConcurrentStreams` value.\n    // A session is considered free when its current streams count\n    // is less than the `maxConcurrentStreams` value.\n    // SESSIONS[NORMALIZED_OPTIONS] = [];\n\n    this.sessions = {}; // The queue for creating new sessions. It looks like this:\n    // QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION\n    //\n    // The entry function has `listeners`, `completed` and `destroyed` properties.\n    // `listeners` is an array of objects containing `resolve` and `reject` functions.\n    // `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.\n    // `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.\n\n    this.queue = {}; // Each session will use this timeout value.\n\n    this.timeout = timeout; // Max sessions in total\n\n    this.maxSessions = maxSessions; // Max free sessions in total\n    // TODO: decreasing `maxFreeSessions` should close some sessions\n\n    this.maxFreeSessions = maxFreeSessions;\n    this._freeSessionsCount = 0;\n    this._sessionsCount = 0; // We don't support push streams by default.\n\n    this.settings = {\n      enablePush: false\n    }; // Reusing TLS sessions increases performance.\n\n    this.tlsSessionCache = new QuickLRU({\n      maxSize: maxCachedTlsSessions\n    });\n  }\n\n  static normalizeOrigin(url, servername) {\n    if (typeof url === 'string') {\n      url = new URL(url);\n    }\n\n    if (servername && url.hostname !== servername) {\n      url.hostname = servername;\n    }\n\n    return url.origin;\n  }\n\n  normalizeOptions(options) {\n    let normalized = '';\n\n    if (options) {\n      for (const key of nameKeys) {\n        if (options[key]) {\n          normalized += `:${options[key]}`;\n        }\n      }\n    }\n\n    return normalized;\n  }\n\n  _tryToCreateNewSession(normalizedOptions, normalizedOrigin) {\n    if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {\n      return;\n    }\n\n    const item = this.queue[normalizedOptions][normalizedOrigin]; // The entry function can be run only once.\n    // BUG: The session may be never created when:\n    // - the first condition is false AND\n    // - this function is never called with the same arguments in the future.\n\n    if (this._sessionsCount < this.maxSessions && !item.completed) {\n      item.completed = true;\n      item();\n    }\n  }\n\n  getSession(origin, options, listeners) {\n    return new Promise((resolve, reject) => {\n      if (Array.isArray(listeners)) {\n        listeners = [...listeners]; // Resolve the current promise ASAP, we're just moving the listeners.\n        // They will be executed at a different time.\n\n        resolve();\n      } else {\n        listeners = [{\n          resolve,\n          reject\n        }];\n      }\n\n      const normalizedOptions = this.normalizeOptions(options);\n      const normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);\n\n      if (normalizedOrigin === undefined) {\n        for (const {\n          reject\n        } of listeners) {\n          reject(new TypeError('The `origin` argument needs to be a string or an URL object'));\n        }\n\n        return;\n      }\n\n      if (normalizedOptions in this.sessions) {\n        const sessions = this.sessions[normalizedOptions];\n        let maxConcurrentStreams = -1;\n        let currentStreamsCount = -1;\n        let optimalSession; // We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.\n        // Additionally, we are looking for session which has biggest current pending streams count.\n\n        for (const session of sessions) {\n          const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;\n\n          if (sessionMaxConcurrentStreams < maxConcurrentStreams) {\n            break;\n          }\n\n          if (session[kOriginSet].includes(normalizedOrigin)) {\n            const sessionCurrentStreamsCount = session[kCurrentStreamsCount];\n\n            if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || // Unfortunately the `close` event isn't called immediately,\n            // so `session.destroyed` is `true`, but `session.closed` is `false`.\n            session.destroyed) {\n              continue;\n            } // We only need set this once.\n\n\n            if (!optimalSession) {\n              maxConcurrentStreams = sessionMaxConcurrentStreams;\n            } // We're looking for the session which has biggest current pending stream count,\n            // in order to minimalize the amount of active sessions.\n\n\n            if (sessionCurrentStreamsCount > currentStreamsCount) {\n              optimalSession = session;\n              currentStreamsCount = sessionCurrentStreamsCount;\n            }\n          }\n        }\n\n        if (optimalSession) {\n          /* istanbul ignore next: safety check */\n          if (listeners.length !== 1) {\n            for (const {\n              reject\n            } of listeners) {\n              const error = new Error(`Expected the length of listeners to be 1, got ${listeners.length}.\\n` + 'Please report this to https://github.com/szmarczak/http2-wrapper/');\n              reject(error);\n            }\n\n            return;\n          }\n\n          listeners[0].resolve(optimalSession);\n          return;\n        }\n      }\n\n      if (normalizedOptions in this.queue) {\n        if (normalizedOrigin in this.queue[normalizedOptions]) {\n          // There's already an item in the queue, just attach ourselves to it.\n          this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners); // This shouldn't be executed here.\n          // See the comment inside _tryToCreateNewSession.\n\n          this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\n          return;\n        }\n      } else {\n        this.queue[normalizedOptions] = {};\n      } // The entry must be removed from the queue IMMEDIATELY when:\n      // 1. the session connects successfully,\n      // 2. an error occurs.\n\n\n      const removeFromQueue = () => {\n        // Our entry can be replaced. We cannot remove the new one.\n        if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {\n          delete this.queue[normalizedOptions][normalizedOrigin];\n\n          if (Object.keys(this.queue[normalizedOptions]).length === 0) {\n            delete this.queue[normalizedOptions];\n          }\n        }\n      }; // The main logic is here\n\n\n      const entry = () => {\n        const name = `${normalizedOrigin}:${normalizedOptions}`;\n        let receivedSettings = false;\n\n        try {\n          const session = http2.connect(origin, {\n            createConnection: this.createConnection,\n            settings: this.settings,\n            session: this.tlsSessionCache.get(name),\n            ...options\n          });\n          session[kCurrentStreamsCount] = 0;\n          session[kGracefullyClosing] = false;\n\n          const isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n\n          let wasFree = true;\n          session.socket.once('session', tlsSession => {\n            this.tlsSessionCache.set(name, tlsSession);\n          });\n          session.once('error', error => {\n            // Listeners are empty when the session successfully connected.\n            for (const {\n              reject\n            } of listeners) {\n              reject(error);\n            } // The connection got broken, purge the cache.\n\n\n            this.tlsSessionCache.delete(name);\n          });\n          session.setTimeout(this.timeout, () => {\n            // Terminates all streams owned by this session.\n            // TODO: Maybe the streams should have a \"Session timed out\" error?\n            session.destroy();\n          });\n          session.once('close', () => {\n            if (receivedSettings) {\n              // 1. If it wasn't free then no need to decrease because\n              //    it has been decreased already in session.request().\n              // 2. `stream.once('close')` won't increment the count\n              //    because the session is already closed.\n              if (wasFree) {\n                this._freeSessionsCount--;\n              }\n\n              this._sessionsCount--; // This cannot be moved to the stream logic,\n              // because there may be a session that hadn't made a single request.\n\n              const where = this.sessions[normalizedOptions];\n              where.splice(where.indexOf(session), 1);\n\n              if (where.length === 0) {\n                delete this.sessions[normalizedOptions];\n              }\n            } else {\n              // Broken connection\n              const error = new Error('Session closed without receiving a SETTINGS frame');\n              error.code = 'HTTP2WRAPPER_NOSETTINGS';\n\n              for (const {\n                reject\n              } of listeners) {\n                reject(error);\n              }\n\n              removeFromQueue();\n            } // There may be another session awaiting.\n\n\n            this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n          }); // Iterates over the queue and processes listeners.\n\n          const processListeners = () => {\n            if (!(normalizedOptions in this.queue) || !isFree()) {\n              return;\n            }\n\n            for (const origin of session[kOriginSet]) {\n              if (origin in this.queue[normalizedOptions]) {\n                const {\n                  listeners\n                } = this.queue[normalizedOptions][origin]; // Prevents session overloading.\n\n                while (listeners.length !== 0 && isFree()) {\n                  // We assume `resolve(...)` calls `request(...)` *directly*,\n                  // otherwise the session will get overloaded.\n                  listeners.shift().resolve(session);\n                }\n\n                const where = this.queue[normalizedOptions];\n\n                if (where[origin].listeners.length === 0) {\n                  delete where[origin];\n\n                  if (Object.keys(where).length === 0) {\n                    delete this.queue[normalizedOptions];\n                    break;\n                  }\n                } // We're no longer free, no point in continuing.\n\n\n                if (!isFree()) {\n                  break;\n                }\n              }\n            }\n          }; // The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.\n\n\n          session.on('origin', () => {\n            session[kOriginSet] = session.originSet;\n\n            if (!isFree()) {\n              // The session is full.\n              return;\n            }\n\n            processListeners(); // Close covered sessions (if possible).\n\n            closeCoveredSessions(this.sessions[normalizedOptions], session);\n          });\n          session.once('remoteSettings', () => {\n            // Fix Node.js bug preventing the process from exiting\n            session.ref();\n            session.unref();\n            this._sessionsCount++; // The Agent could have been destroyed already.\n\n            if (entry.destroyed) {\n              const error = new Error('Agent has been destroyed');\n\n              for (const listener of listeners) {\n                listener.reject(error);\n              }\n\n              session.destroy();\n              return;\n            }\n\n            session[kOriginSet] = session.originSet;\n            {\n              const where = this.sessions;\n\n              if (normalizedOptions in where) {\n                const sessions = where[normalizedOptions];\n                sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);\n              } else {\n                where[normalizedOptions] = [session];\n              }\n            }\n            this._freeSessionsCount += 1;\n            receivedSettings = true;\n            this.emit('session', session);\n            processListeners();\n            removeFromQueue(); // TODO: Close last recently used (or least used?) session\n\n            if (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {\n              session.close();\n            } // Check if we haven't managed to execute all listeners.\n\n\n            if (listeners.length !== 0) {\n              // Request for a new session with predefined listeners.\n              this.getSession(normalizedOrigin, options, listeners);\n              listeners.length = 0;\n            } // `session.remoteSettings.maxConcurrentStreams` might get increased\n\n\n            session.on('remoteSettings', () => {\n              processListeners(); // In case the Origin Set changes\n\n              closeCoveredSessions(this.sessions[normalizedOptions], session);\n            });\n          }); // Shim `session.request()` in order to catch all streams\n\n          session[kRequest] = session.request;\n\n          session.request = (headers, streamOptions) => {\n            if (session[kGracefullyClosing]) {\n              throw new Error('The session is gracefully closing. No new streams are allowed.');\n            }\n\n            const stream = session[kRequest](headers, streamOptions); // The process won't exit until the session is closed or all requests are gone.\n\n            session.ref();\n            ++session[kCurrentStreamsCount];\n\n            if (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {\n              this._freeSessionsCount--;\n            }\n\n            stream.once('close', () => {\n              wasFree = isFree();\n              --session[kCurrentStreamsCount];\n\n              if (!session.destroyed && !session.closed) {\n                closeSessionIfCovered(this.sessions[normalizedOptions], session);\n\n                if (isFree() && !session.closed) {\n                  if (!wasFree) {\n                    this._freeSessionsCount++;\n                    wasFree = true;\n                  }\n\n                  const isEmpty = session[kCurrentStreamsCount] === 0;\n\n                  if (isEmpty) {\n                    session.unref();\n                  }\n\n                  if (isEmpty && (this._freeSessionsCount > this.maxFreeSessions || session[kGracefullyClosing])) {\n                    session.close();\n                  } else {\n                    closeCoveredSessions(this.sessions[normalizedOptions], session);\n                    processListeners();\n                  }\n                }\n              }\n            });\n            return stream;\n          };\n        } catch (error) {\n          for (const listener of listeners) {\n            listener.reject(error);\n          }\n\n          removeFromQueue();\n        }\n      };\n\n      entry.listeners = listeners;\n      entry.completed = false;\n      entry.destroyed = false;\n      this.queue[normalizedOptions][normalizedOrigin] = entry;\n\n      this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n    });\n  }\n\n  request(origin, options, headers, streamOptions) {\n    return new Promise((resolve, reject) => {\n      this.getSession(origin, options, [{\n        reject,\n        resolve: session => {\n          try {\n            resolve(session.request(headers, streamOptions));\n          } catch (error) {\n            reject(error);\n          }\n        }\n      }]);\n    });\n  }\n\n  createConnection(origin, options) {\n    return Agent.connect(origin, options);\n  }\n\n  static connect(origin, options) {\n    options.ALPNProtocols = ['h2'];\n    const port = origin.port || 443;\n    const host = origin.hostname || origin.host;\n\n    if (typeof options.servername === 'undefined') {\n      options.servername = host;\n    }\n\n    return tls.connect(port, host, options);\n  }\n\n  closeFreeSessions() {\n    for (const sessions of Object.values(this.sessions)) {\n      for (const session of sessions) {\n        if (session[kCurrentStreamsCount] === 0) {\n          session.close();\n        }\n      }\n    }\n  }\n\n  destroy(reason) {\n    for (const sessions of Object.values(this.sessions)) {\n      for (const session of sessions) {\n        session.destroy(reason);\n      }\n    }\n\n    for (const entriesOfAuthority of Object.values(this.queue)) {\n      for (const entry of Object.values(entriesOfAuthority)) {\n        entry.destroyed = true;\n      }\n    } // New requests should NOT attach to destroyed sessions\n\n\n    this.queue = {};\n  }\n\n  get freeSessions() {\n    return getSessions({\n      agent: this,\n      isFree: true\n    });\n  }\n\n  get busySessions() {\n    return getSessions({\n      agent: this,\n      isFree: false\n    });\n  }\n\n}\n\nAgent.kCurrentStreamsCount = kCurrentStreamsCount;\nAgent.kGracefullyClosing = kGracefullyClosing;\nmodule.exports = {\n  Agent,\n  globalAgent: new Agent()\n};","map":{"version":3,"sources":["/Users/dhruv/Sneaks/sneaks-website/node_modules/http2-wrapper/source/agent.js"],"names":["EventEmitter","require","tls","http2","QuickLRU","kCurrentStreamsCount","Symbol","kRequest","kOriginSet","kGracefullyClosing","nameKeys","getSortedIndex","array","value","compare","low","high","length","mid","compareSessions","a","b","remoteSettings","maxConcurrentStreams","closeCoveredSessions","where","session","coveredSession","every","origin","includes","gracefullyClose","closeSessionIfCovered","getSessions","agent","isFree","result","normalizedOptions","sessions","filtered","filter","Agent","close","constructor","timeout","maxSessions","Infinity","maxFreeSessions","maxCachedTlsSessions","queue","_freeSessionsCount","_sessionsCount","settings","enablePush","tlsSessionCache","maxSize","normalizeOrigin","url","servername","URL","hostname","normalizeOptions","options","normalized","key","_tryToCreateNewSession","normalizedOrigin","item","completed","getSession","listeners","Promise","resolve","reject","Array","isArray","undefined","TypeError","currentStreamsCount","optimalSession","sessionMaxConcurrentStreams","sessionCurrentStreamsCount","destroyed","error","Error","push","removeFromQueue","entry","Object","keys","name","receivedSettings","connect","createConnection","get","wasFree","socket","once","tlsSession","set","delete","setTimeout","destroy","splice","indexOf","code","processListeners","shift","on","originSet","ref","unref","listener","emit","request","headers","streamOptions","stream","closed","isEmpty","ALPNProtocols","port","host","closeFreeSessions","values","reason","entriesOfAuthority","freeSessions","busySessions","module","exports","globalAgent"],"mappings":"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","sourcesContent":["'use strict';\nconst EventEmitter = require('events');\nconst tls = require('tls');\nconst http2 = require('http2');\nconst QuickLRU = require('quick-lru');\n\nconst kCurrentStreamsCount = Symbol('currentStreamsCount');\nconst kRequest = Symbol('request');\nconst kOriginSet = Symbol('cachedOriginSet');\nconst kGracefullyClosing = Symbol('gracefullyClosing');\n\nconst nameKeys = [\n\t// `http2.connect()` options\n\t'maxDeflateDynamicTableSize',\n\t'maxSessionMemory',\n\t'maxHeaderListPairs',\n\t'maxOutstandingPings',\n\t'maxReservedRemoteStreams',\n\t'maxSendHeaderBlockLength',\n\t'paddingStrategy',\n\n\t// `tls.connect()` options\n\t'localAddress',\n\t'path',\n\t'rejectUnauthorized',\n\t'minDHSize',\n\n\t// `tls.createSecureContext()` options\n\t'ca',\n\t'cert',\n\t'clientCertEngine',\n\t'ciphers',\n\t'key',\n\t'pfx',\n\t'servername',\n\t'minVersion',\n\t'maxVersion',\n\t'secureProtocol',\n\t'crl',\n\t'honorCipherOrder',\n\t'ecdhCurve',\n\t'dhparam',\n\t'secureOptions',\n\t'sessionIdContext'\n];\n\nconst getSortedIndex = (array, value, compare) => {\n\tlet low = 0;\n\tlet high = array.length;\n\n\twhile (low < high) {\n\t\tconst mid = (low + high) >>> 1;\n\n\t\t/* istanbul ignore next */\n\t\tif (compare(array[mid], value)) {\n\t\t\t// This never gets called because we use descending sort. Better to have this anyway.\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\n\treturn low;\n};\n\nconst compareSessions = (a, b) => {\n\treturn a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;\n};\n\n// See https://tools.ietf.org/html/rfc8336\nconst closeCoveredSessions = (where, session) => {\n\t// Clients SHOULD NOT emit new requests on any connection whose Origin\n\t// Set is a proper subset of another connection's Origin Set, and they\n\t// SHOULD close it once all outstanding requests are satisfied.\n\tfor (const coveredSession of where) {\n\t\tif (\n\t\t\t// The set is a proper subset when its length is less than the other set.\n\t\t\tcoveredSession[kOriginSet].length < session[kOriginSet].length &&\n\n\t\t\t// And the other set includes all elements of the subset.\n\t\t\tcoveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&\n\n\t\t\t// Makes sure that the session can handle all requests from the covered session.\n\t\t\tcoveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\t// This allows pending requests to finish and prevents making new requests.\n\t\t\tgracefullyClose(coveredSession);\n\t\t}\n\t}\n};\n\n// This is basically inverted `closeCoveredSessions(...)`.\nconst closeSessionIfCovered = (where, coveredSession) => {\n\tfor (const session of where) {\n\t\tif (\n\t\t\tcoveredSession[kOriginSet].length < session[kOriginSet].length &&\n\t\t\tcoveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&\n\t\t\tcoveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\tgracefullyClose(coveredSession);\n\t\t}\n\t}\n};\n\nconst getSessions = ({agent, isFree}) => {\n\tconst result = {};\n\n\t// eslint-disable-next-line guard-for-in\n\tfor (const normalizedOptions in agent.sessions) {\n\t\tconst sessions = agent.sessions[normalizedOptions];\n\n\t\tconst filtered = sessions.filter(session => {\n\t\t\tconst result = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n\n\t\t\treturn isFree ? result : !result;\n\t\t});\n\n\t\tif (filtered.length !== 0) {\n\t\t\tresult[normalizedOptions] = filtered;\n\t\t}\n\t}\n\n\treturn result;\n};\n\nconst gracefullyClose = session => {\n\tsession[kGracefullyClosing] = true;\n\n\tif (session[kCurrentStreamsCount] === 0) {\n\t\tsession.close();\n\t}\n};\n\nclass Agent extends EventEmitter {\n\tconstructor({timeout = 60000, maxSessions = Infinity, maxFreeSessions = 10, maxCachedTlsSessions = 100} = {}) {\n\t\tsuper();\n\n\t\t// A session is considered busy when its current streams count\n\t\t// is equal to or greater than the `maxConcurrentStreams` value.\n\n\t\t// A session is considered free when its current streams count\n\t\t// is less than the `maxConcurrentStreams` value.\n\n\t\t// SESSIONS[NORMALIZED_OPTIONS] = [];\n\t\tthis.sessions = {};\n\n\t\t// The queue for creating new sessions. It looks like this:\n\t\t// QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION\n\t\t//\n\t\t// The entry function has `listeners`, `completed` and `destroyed` properties.\n\t\t// `listeners` is an array of objects containing `resolve` and `reject` functions.\n\t\t// `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.\n\t\t// `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.\n\t\tthis.queue = {};\n\n\t\t// Each session will use this timeout value.\n\t\tthis.timeout = timeout;\n\n\t\t// Max sessions in total\n\t\tthis.maxSessions = maxSessions;\n\n\t\t// Max free sessions in total\n\t\t// TODO: decreasing `maxFreeSessions` should close some sessions\n\t\tthis.maxFreeSessions = maxFreeSessions;\n\n\t\tthis._freeSessionsCount = 0;\n\t\tthis._sessionsCount = 0;\n\n\t\t// We don't support push streams by default.\n\t\tthis.settings = {\n\t\t\tenablePush: false\n\t\t};\n\n\t\t// Reusing TLS sessions increases performance.\n\t\tthis.tlsSessionCache = new QuickLRU({maxSize: maxCachedTlsSessions});\n\t}\n\n\tstatic normalizeOrigin(url, servername) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = new URL(url);\n\t\t}\n\n\t\tif (servername && url.hostname !== servername) {\n\t\t\turl.hostname = servername;\n\t\t}\n\n\t\treturn url.origin;\n\t}\n\n\tnormalizeOptions(options) {\n\t\tlet normalized = '';\n\n\t\tif (options) {\n\t\t\tfor (const key of nameKeys) {\n\t\t\t\tif (options[key]) {\n\t\t\t\t\tnormalized += `:${options[key]}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn normalized;\n\t}\n\n\t_tryToCreateNewSession(normalizedOptions, normalizedOrigin) {\n\t\tif (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst item = this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t// The entry function can be run only once.\n\t\t// BUG: The session may be never created when:\n\t\t// - the first condition is false AND\n\t\t// - this function is never called with the same arguments in the future.\n\t\tif (this._sessionsCount < this.maxSessions && !item.completed) {\n\t\t\titem.completed = true;\n\n\t\t\titem();\n\t\t}\n\t}\n\n\tgetSession(origin, options, listeners) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (Array.isArray(listeners)) {\n\t\t\t\tlisteners = [...listeners];\n\n\t\t\t\t// Resolve the current promise ASAP, we're just moving the listeners.\n\t\t\t\t// They will be executed at a different time.\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\tlisteners = [{resolve, reject}];\n\t\t\t}\n\n\t\t\tconst normalizedOptions = this.normalizeOptions(options);\n\t\t\tconst normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);\n\n\t\t\tif (normalizedOrigin === undefined) {\n\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\treject(new TypeError('The `origin` argument needs to be a string or an URL object'));\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (normalizedOptions in this.sessions) {\n\t\t\t\tconst sessions = this.sessions[normalizedOptions];\n\n\t\t\t\tlet maxConcurrentStreams = -1;\n\t\t\t\tlet currentStreamsCount = -1;\n\t\t\t\tlet optimalSession;\n\n\t\t\t\t// We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.\n\t\t\t\t// Additionally, we are looking for session which has biggest current pending streams count.\n\t\t\t\tfor (const session of sessions) {\n\t\t\t\t\tconst sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;\n\n\t\t\t\t\tif (sessionMaxConcurrentStreams < maxConcurrentStreams) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (session[kOriginSet].includes(normalizedOrigin)) {\n\t\t\t\t\t\tconst sessionCurrentStreamsCount = session[kCurrentStreamsCount];\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tsessionCurrentStreamsCount >= sessionMaxConcurrentStreams ||\n\t\t\t\t\t\t\tsession[kGracefullyClosing] ||\n\t\t\t\t\t\t\t// Unfortunately the `close` event isn't called immediately,\n\t\t\t\t\t\t\t// so `session.destroyed` is `true`, but `session.closed` is `false`.\n\t\t\t\t\t\t\tsession.destroyed\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We only need set this once.\n\t\t\t\t\t\tif (!optimalSession) {\n\t\t\t\t\t\t\tmaxConcurrentStreams = sessionMaxConcurrentStreams;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We're looking for the session which has biggest current pending stream count,\n\t\t\t\t\t\t// in order to minimalize the amount of active sessions.\n\t\t\t\t\t\tif (sessionCurrentStreamsCount > currentStreamsCount) {\n\t\t\t\t\t\t\toptimalSession = session;\n\t\t\t\t\t\t\tcurrentStreamsCount = sessionCurrentStreamsCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (optimalSession) {\n\t\t\t\t\t/* istanbul ignore next: safety check */\n\t\t\t\t\tif (listeners.length !== 1) {\n\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\tconst error = new Error(\n\t\t\t\t\t\t\t\t`Expected the length of listeners to be 1, got ${listeners.length}.\\n` +\n\t\t\t\t\t\t\t\t'Please report this to https://github.com/szmarczak/http2-wrapper/'\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlisteners[0].resolve(optimalSession);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (normalizedOptions in this.queue) {\n\t\t\t\tif (normalizedOrigin in this.queue[normalizedOptions]) {\n\t\t\t\t\t// There's already an item in the queue, just attach ourselves to it.\n\t\t\t\t\tthis.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);\n\n\t\t\t\t\t// This shouldn't be executed here.\n\t\t\t\t\t// See the comment inside _tryToCreateNewSession.\n\t\t\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.queue[normalizedOptions] = {};\n\t\t\t}\n\n\t\t\t// The entry must be removed from the queue IMMEDIATELY when:\n\t\t\t// 1. the session connects successfully,\n\t\t\t// 2. an error occurs.\n\t\t\tconst removeFromQueue = () => {\n\t\t\t\t// Our entry can be replaced. We cannot remove the new one.\n\t\t\t\tif (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {\n\t\t\t\t\tdelete this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t\t\t\tif (Object.keys(this.queue[normalizedOptions]).length === 0) {\n\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// The main logic is here\n\t\t\tconst entry = () => {\n\t\t\t\tconst name = `${normalizedOrigin}:${normalizedOptions}`;\n\t\t\t\tlet receivedSettings = false;\n\n\t\t\t\ttry {\n\t\t\t\t\tconst session = http2.connect(origin, {\n\t\t\t\t\t\tcreateConnection: this.createConnection,\n\t\t\t\t\t\tsettings: this.settings,\n\t\t\t\t\t\tsession: this.tlsSessionCache.get(name),\n\t\t\t\t\t\t...options\n\t\t\t\t\t});\n\t\t\t\t\tsession[kCurrentStreamsCount] = 0;\n\t\t\t\t\tsession[kGracefullyClosing] = false;\n\n\t\t\t\t\tconst isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n\t\t\t\t\tlet wasFree = true;\n\n\t\t\t\t\tsession.socket.once('session', tlsSession => {\n\t\t\t\t\t\tthis.tlsSessionCache.set(name, tlsSession);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('error', error => {\n\t\t\t\t\t\t// Listeners are empty when the session successfully connected.\n\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The connection got broken, purge the cache.\n\t\t\t\t\t\tthis.tlsSessionCache.delete(name);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.setTimeout(this.timeout, () => {\n\t\t\t\t\t\t// Terminates all streams owned by this session.\n\t\t\t\t\t\t// TODO: Maybe the streams should have a \"Session timed out\" error?\n\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('close', () => {\n\t\t\t\t\t\tif (receivedSettings) {\n\t\t\t\t\t\t\t// 1. If it wasn't free then no need to decrease because\n\t\t\t\t\t\t\t//    it has been decreased already in session.request().\n\t\t\t\t\t\t\t// 2. `stream.once('close')` won't increment the count\n\t\t\t\t\t\t\t//    because the session is already closed.\n\t\t\t\t\t\t\tif (wasFree) {\n\t\t\t\t\t\t\t\tthis._freeSessionsCount--;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._sessionsCount--;\n\n\t\t\t\t\t\t\t// This cannot be moved to the stream logic,\n\t\t\t\t\t\t\t// because there may be a session that hadn't made a single request.\n\t\t\t\t\t\t\tconst where = this.sessions[normalizedOptions];\n\t\t\t\t\t\t\twhere.splice(where.indexOf(session), 1);\n\n\t\t\t\t\t\t\tif (where.length === 0) {\n\t\t\t\t\t\t\t\tdelete this.sessions[normalizedOptions];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Broken connection\n\t\t\t\t\t\t\tconst error = new Error('Session closed without receiving a SETTINGS frame');\n\t\t\t\t\t\t\terror.code = 'HTTP2WRAPPER_NOSETTINGS';\n\n\t\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tremoveFromQueue();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// There may be another session awaiting.\n\t\t\t\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t\t\t\t});\n\n\t\t\t\t\t// Iterates over the queue and processes listeners.\n\t\t\t\t\tconst processListeners = () => {\n\t\t\t\t\t\tif (!(normalizedOptions in this.queue) || !isFree()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const origin of session[kOriginSet]) {\n\t\t\t\t\t\t\tif (origin in this.queue[normalizedOptions]) {\n\t\t\t\t\t\t\t\tconst {listeners} = this.queue[normalizedOptions][origin];\n\n\t\t\t\t\t\t\t\t// Prevents session overloading.\n\t\t\t\t\t\t\t\twhile (listeners.length !== 0 && isFree()) {\n\t\t\t\t\t\t\t\t\t// We assume `resolve(...)` calls `request(...)` *directly*,\n\t\t\t\t\t\t\t\t\t// otherwise the session will get overloaded.\n\t\t\t\t\t\t\t\t\tlisteners.shift().resolve(session);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst where = this.queue[normalizedOptions];\n\t\t\t\t\t\t\t\tif (where[origin].listeners.length === 0) {\n\t\t\t\t\t\t\t\t\tdelete where[origin];\n\n\t\t\t\t\t\t\t\t\tif (Object.keys(where).length === 0) {\n\t\t\t\t\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// We're no longer free, no point in continuing.\n\t\t\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.\n\t\t\t\t\tsession.on('origin', () => {\n\t\t\t\t\t\tsession[kOriginSet] = session.originSet;\n\n\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t// The session is full.\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t// Close covered sessions (if possible).\n\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('remoteSettings', () => {\n\t\t\t\t\t\t// Fix Node.js bug preventing the process from exiting\n\t\t\t\t\t\tsession.ref();\n\t\t\t\t\t\tsession.unref();\n\n\t\t\t\t\t\tthis._sessionsCount++;\n\n\t\t\t\t\t\t// The Agent could have been destroyed already.\n\t\t\t\t\t\tif (entry.destroyed) {\n\t\t\t\t\t\t\tconst error = new Error('Agent has been destroyed');\n\n\t\t\t\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\t\t\t\tlistener.reject(error);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsession[kOriginSet] = session.originSet;\n\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst where = this.sessions;\n\n\t\t\t\t\t\t\tif (normalizedOptions in where) {\n\t\t\t\t\t\t\t\tconst sessions = where[normalizedOptions];\n\t\t\t\t\t\t\t\tsessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twhere[normalizedOptions] = [session];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._freeSessionsCount += 1;\n\t\t\t\t\t\treceivedSettings = true;\n\n\t\t\t\t\t\tthis.emit('session', session);\n\n\t\t\t\t\t\tprocessListeners();\n\t\t\t\t\t\tremoveFromQueue();\n\n\t\t\t\t\t\t// TODO: Close last recently used (or least used?) session\n\t\t\t\t\t\tif (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {\n\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check if we haven't managed to execute all listeners.\n\t\t\t\t\t\tif (listeners.length !== 0) {\n\t\t\t\t\t\t\t// Request for a new session with predefined listeners.\n\t\t\t\t\t\t\tthis.getSession(normalizedOrigin, options, listeners);\n\t\t\t\t\t\t\tlisteners.length = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// `session.remoteSettings.maxConcurrentStreams` might get increased\n\t\t\t\t\t\tsession.on('remoteSettings', () => {\n\t\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t\t// In case the Origin Set changes\n\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\t// Shim `session.request()` in order to catch all streams\n\t\t\t\t\tsession[kRequest] = session.request;\n\t\t\t\t\tsession.request = (headers, streamOptions) => {\n\t\t\t\t\t\tif (session[kGracefullyClosing]) {\n\t\t\t\t\t\t\tthrow new Error('The session is gracefully closing. No new streams are allowed.');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst stream = session[kRequest](headers, streamOptions);\n\n\t\t\t\t\t\t// The process won't exit until the session is closed or all requests are gone.\n\t\t\t\t\t\tsession.ref();\n\n\t\t\t\t\t\t++session[kCurrentStreamsCount];\n\n\t\t\t\t\t\tif (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {\n\t\t\t\t\t\t\tthis._freeSessionsCount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstream.once('close', () => {\n\t\t\t\t\t\t\twasFree = isFree();\n\n\t\t\t\t\t\t\t--session[kCurrentStreamsCount];\n\n\t\t\t\t\t\t\tif (!session.destroyed && !session.closed) {\n\t\t\t\t\t\t\t\tcloseSessionIfCovered(this.sessions[normalizedOptions], session);\n\n\t\t\t\t\t\t\t\tif (isFree() && !session.closed) {\n\t\t\t\t\t\t\t\t\tif (!wasFree) {\n\t\t\t\t\t\t\t\t\t\tthis._freeSessionsCount++;\n\n\t\t\t\t\t\t\t\t\t\twasFree = true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst isEmpty = session[kCurrentStreamsCount] === 0;\n\n\t\t\t\t\t\t\t\t\tif (isEmpty) {\n\t\t\t\t\t\t\t\t\t\tsession.unref();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tisEmpty &&\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tthis._freeSessionsCount > this.maxFreeSessions ||\n\t\t\t\t\t\t\t\t\t\t\tsession[kGracefullyClosing]\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t\t\t\t\tprocessListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn stream;\n\t\t\t\t\t};\n\t\t\t\t} catch (error) {\n\t\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\t\tlistener.reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveFromQueue();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tentry.listeners = listeners;\n\t\t\tentry.completed = false;\n\t\t\tentry.destroyed = false;\n\n\t\t\tthis.queue[normalizedOptions][normalizedOrigin] = entry;\n\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t});\n\t}\n\n\trequest(origin, options, headers, streamOptions) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.getSession(origin, options, [{\n\t\t\t\treject,\n\t\t\t\tresolve: session => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolve(session.request(headers, streamOptions));\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}]);\n\t\t});\n\t}\n\n\tcreateConnection(origin, options) {\n\t\treturn Agent.connect(origin, options);\n\t}\n\n\tstatic connect(origin, options) {\n\t\toptions.ALPNProtocols = ['h2'];\n\n\t\tconst port = origin.port || 443;\n\t\tconst host = origin.hostname || origin.host;\n\n\t\tif (typeof options.servername === 'undefined') {\n\t\t\toptions.servername = host;\n\t\t}\n\n\t\treturn tls.connect(port, host, options);\n\t}\n\n\tcloseFreeSessions() {\n\t\tfor (const sessions of Object.values(this.sessions)) {\n\t\t\tfor (const session of sessions) {\n\t\t\t\tif (session[kCurrentStreamsCount] === 0) {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy(reason) {\n\t\tfor (const sessions of Object.values(this.sessions)) {\n\t\t\tfor (const session of sessions) {\n\t\t\t\tsession.destroy(reason);\n\t\t\t}\n\t\t}\n\n\t\tfor (const entriesOfAuthority of Object.values(this.queue)) {\n\t\t\tfor (const entry of Object.values(entriesOfAuthority)) {\n\t\t\t\tentry.destroyed = true;\n\t\t\t}\n\t\t}\n\n\t\t// New requests should NOT attach to destroyed sessions\n\t\tthis.queue = {};\n\t}\n\n\tget freeSessions() {\n\t\treturn getSessions({agent: this, isFree: true});\n\t}\n\n\tget busySessions() {\n\t\treturn getSessions({agent: this, isFree: false});\n\t}\n}\n\nAgent.kCurrentStreamsCount = kCurrentStreamsCount;\nAgent.kGracefullyClosing = kGracefullyClosing;\n\nmodule.exports = {\n\tAgent,\n\tglobalAgent: new Agent()\n};\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst urlLib = require('url');\n\nconst normalizeUrl = require('normalize-url');\n\nconst getStream = require('get-stream');\n\nconst CachePolicy = require('http-cache-semantics');\n\nconst Response = require('responselike');\n\nconst lowercaseKeys = require('lowercase-keys');\n\nconst cloneResponse = require('clone-response');\n\nconst Keyv = require('keyv');\n\nclass CacheableRequest {\n  constructor(request, cacheAdapter) {\n    if (typeof request !== 'function') {\n      throw new TypeError('Parameter `request` must be a function');\n    }\n\n    this.cache = new Keyv({\n      uri: typeof cacheAdapter === 'string' && cacheAdapter,\n      store: typeof cacheAdapter !== 'string' && cacheAdapter,\n      namespace: 'cacheable-request'\n    });\n    return this.createCacheableRequest(request);\n  }\n\n  createCacheableRequest(request) {\n    return (opts, cb) => {\n      let url;\n\n      if (typeof opts === 'string') {\n        url = normalizeUrlObject(urlLib.parse(opts));\n        opts = {};\n      } else if (opts instanceof urlLib.URL) {\n        url = normalizeUrlObject(urlLib.parse(opts.toString()));\n        opts = {};\n      } else {\n        const [pathname, ...searchParts] = (opts.path || '').split('?');\n        const search = searchParts.length > 0 ? `?${searchParts.join('?')}` : '';\n        url = normalizeUrlObject({ ...opts,\n          pathname,\n          search\n        });\n      }\n\n      opts = {\n        headers: {},\n        method: 'GET',\n        cache: true,\n        strictTtl: false,\n        automaticFailover: false,\n        ...opts,\n        ...urlObjectToRequestOptions(url)\n      };\n      opts.headers = lowercaseKeys(opts.headers);\n      const ee = new EventEmitter();\n      const normalizedUrlString = normalizeUrl(urlLib.format(url), {\n        stripWWW: false,\n        removeTrailingSlash: false,\n        stripAuthentication: false\n      });\n      const key = `${opts.method}:${normalizedUrlString}`;\n      let revalidate = false;\n      let madeRequest = false;\n\n      const makeRequest = opts => {\n        madeRequest = true;\n        let requestErrored = false;\n        let requestErrorCallback;\n        const requestErrorPromise = new Promise(resolve => {\n          requestErrorCallback = () => {\n            if (!requestErrored) {\n              requestErrored = true;\n              resolve();\n            }\n          };\n        });\n\n        const handler = response => {\n          if (revalidate && !opts.forceRefresh) {\n            response.status = response.statusCode;\n            const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);\n\n            if (!revalidatedPolicy.modified) {\n              const headers = revalidatedPolicy.policy.responseHeaders();\n              response = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);\n              response.cachePolicy = revalidatedPolicy.policy;\n              response.fromCache = true;\n            }\n          }\n\n          if (!response.fromCache) {\n            response.cachePolicy = new CachePolicy(opts, response, opts);\n            response.fromCache = false;\n          }\n\n          let clonedResponse;\n\n          if (opts.cache && response.cachePolicy.storable()) {\n            clonedResponse = cloneResponse(response);\n\n            (async () => {\n              try {\n                const bodyPromise = getStream.buffer(response);\n                await Promise.race([requestErrorPromise, new Promise(resolve => response.once('end', resolve))]);\n\n                if (requestErrored) {\n                  return;\n                }\n\n                const body = await bodyPromise;\n                const value = {\n                  cachePolicy: response.cachePolicy.toObject(),\n                  url: response.url,\n                  statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,\n                  body\n                };\n                let ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;\n\n                if (opts.maxTtl) {\n                  ttl = ttl ? Math.min(ttl, opts.maxTtl) : opts.maxTtl;\n                }\n\n                await this.cache.set(key, value, ttl);\n              } catch (error) {\n                ee.emit('error', new CacheableRequest.CacheError(error));\n              }\n            })();\n          } else if (opts.cache && revalidate) {\n            (async () => {\n              try {\n                await this.cache.delete(key);\n              } catch (error) {\n                ee.emit('error', new CacheableRequest.CacheError(error));\n              }\n            })();\n          }\n\n          ee.emit('response', clonedResponse || response);\n\n          if (typeof cb === 'function') {\n            cb(clonedResponse || response);\n          }\n        };\n\n        try {\n          const req = request(opts, handler);\n          req.once('error', requestErrorCallback);\n          req.once('abort', requestErrorCallback);\n          ee.emit('request', req);\n        } catch (error) {\n          ee.emit('error', new CacheableRequest.RequestError(error));\n        }\n      };\n\n      (async () => {\n        const get = async opts => {\n          await Promise.resolve();\n          const cacheEntry = opts.cache ? await this.cache.get(key) : undefined;\n\n          if (typeof cacheEntry === 'undefined') {\n            return makeRequest(opts);\n          }\n\n          const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);\n\n          if (policy.satisfiesWithoutRevalidation(opts) && !opts.forceRefresh) {\n            const headers = policy.responseHeaders();\n            const response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);\n            response.cachePolicy = policy;\n            response.fromCache = true;\n            ee.emit('response', response);\n\n            if (typeof cb === 'function') {\n              cb(response);\n            }\n          } else {\n            revalidate = cacheEntry;\n            opts.headers = policy.revalidationHeaders(opts);\n            makeRequest(opts);\n          }\n        };\n\n        const errorHandler = error => ee.emit('error', new CacheableRequest.CacheError(error));\n\n        this.cache.once('error', errorHandler);\n        ee.on('response', () => this.cache.removeListener('error', errorHandler));\n\n        try {\n          await get(opts);\n        } catch (error) {\n          if (opts.automaticFailover && !madeRequest) {\n            makeRequest(opts);\n          }\n\n          ee.emit('error', new CacheableRequest.CacheError(error));\n        }\n      })();\n\n      return ee;\n    };\n  }\n\n}\n\nfunction urlObjectToRequestOptions(url) {\n  const options = { ...url\n  };\n  options.path = `${url.pathname || '/'}${url.search || ''}`;\n  delete options.pathname;\n  delete options.search;\n  return options;\n}\n\nfunction normalizeUrlObject(url) {\n  // If url was parsed by url.parse or new URL:\n  // - hostname will be set\n  // - host will be hostname[:port]\n  // - port will be set if it was explicit in the parsed string\n  // Otherwise, url was from request options:\n  // - hostname or host may be set\n  // - host shall not have port encoded\n  return {\n    protocol: url.protocol,\n    auth: url.auth,\n    hostname: url.hostname || url.host || 'localhost',\n    port: url.port,\n    pathname: url.pathname,\n    search: url.search\n  };\n}\n\nCacheableRequest.RequestError = class extends Error {\n  constructor(error) {\n    super(error.message);\n    this.name = 'RequestError';\n    Object.assign(this, error);\n  }\n\n};\nCacheableRequest.CacheError = class extends Error {\n  constructor(error) {\n    super(error.message);\n    this.name = 'CacheError';\n    Object.assign(this, error);\n  }\n\n};\nmodule.exports = CacheableRequest;","map":{"version":3,"sources":["/Users/dhruv/Sneaks/sneaks-website/node_modules/cacheable-request/src/index.js"],"names":["EventEmitter","require","urlLib","normalizeUrl","getStream","CachePolicy","Response","lowercaseKeys","cloneResponse","Keyv","CacheableRequest","constructor","request","cacheAdapter","TypeError","cache","uri","store","namespace","createCacheableRequest","opts","cb","url","normalizeUrlObject","parse","URL","toString","pathname","searchParts","path","split","search","length","join","headers","method","strictTtl","automaticFailover","urlObjectToRequestOptions","ee","normalizedUrlString","format","stripWWW","removeTrailingSlash","stripAuthentication","key","revalidate","madeRequest","makeRequest","requestErrored","requestErrorCallback","requestErrorPromise","Promise","resolve","handler","response","forceRefresh","status","statusCode","revalidatedPolicy","fromObject","cachePolicy","modified","policy","responseHeaders","body","fromCache","clonedResponse","storable","bodyPromise","buffer","race","once","value","toObject","ttl","timeToLive","undefined","maxTtl","Math","min","set","error","emit","CacheError","delete","req","RequestError","get","cacheEntry","satisfiesWithoutRevalidation","revalidationHeaders","errorHandler","on","removeListener","options","protocol","auth","hostname","host","port","Error","message","name","Object","assign","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst urlLib = require('url');\nconst normalizeUrl = require('normalize-url');\nconst getStream = require('get-stream');\nconst CachePolicy = require('http-cache-semantics');\nconst Response = require('responselike');\nconst lowercaseKeys = require('lowercase-keys');\nconst cloneResponse = require('clone-response');\nconst Keyv = require('keyv');\n\nclass CacheableRequest {\n\tconstructor(request, cacheAdapter) {\n\t\tif (typeof request !== 'function') {\n\t\t\tthrow new TypeError('Parameter `request` must be a function');\n\t\t}\n\n\t\tthis.cache = new Keyv({\n\t\t\turi: typeof cacheAdapter === 'string' && cacheAdapter,\n\t\t\tstore: typeof cacheAdapter !== 'string' && cacheAdapter,\n\t\t\tnamespace: 'cacheable-request'\n\t\t});\n\n\t\treturn this.createCacheableRequest(request);\n\t}\n\n\tcreateCacheableRequest(request) {\n\t\treturn (opts, cb) => {\n\t\t\tlet url;\n\t\t\tif (typeof opts === 'string') {\n\t\t\t\turl = normalizeUrlObject(urlLib.parse(opts));\n\t\t\t\topts = {};\n\t\t\t} else if (opts instanceof urlLib.URL) {\n\t\t\t\turl = normalizeUrlObject(urlLib.parse(opts.toString()));\n\t\t\t\topts = {};\n\t\t\t} else {\n\t\t\t\tconst [pathname, ...searchParts] = (opts.path || '').split('?');\n\t\t\t\tconst search = searchParts.length > 0 ?\n\t\t\t\t\t`?${searchParts.join('?')}` :\n\t\t\t\t\t'';\n\t\t\t\turl = normalizeUrlObject({ ...opts, pathname, search });\n\t\t\t}\n\n\t\t\topts = {\n\t\t\t\theaders: {},\n\t\t\t\tmethod: 'GET',\n\t\t\t\tcache: true,\n\t\t\t\tstrictTtl: false,\n\t\t\t\tautomaticFailover: false,\n\t\t\t\t...opts,\n\t\t\t\t...urlObjectToRequestOptions(url)\n\t\t\t};\n\t\t\topts.headers = lowercaseKeys(opts.headers);\n\n\t\t\tconst ee = new EventEmitter();\n\t\t\tconst normalizedUrlString = normalizeUrl(\n\t\t\t\turlLib.format(url),\n\t\t\t\t{\n\t\t\t\t\tstripWWW: false,\n\t\t\t\t\tremoveTrailingSlash: false,\n\t\t\t\t\tstripAuthentication: false\n\t\t\t\t}\n\t\t\t);\n\t\t\tconst key = `${opts.method}:${normalizedUrlString}`;\n\t\t\tlet revalidate = false;\n\t\t\tlet madeRequest = false;\n\n\t\t\tconst makeRequest = opts => {\n\t\t\t\tmadeRequest = true;\n\t\t\t\tlet requestErrored = false;\n\t\t\t\tlet requestErrorCallback;\n\n\t\t\t\tconst requestErrorPromise = new Promise(resolve => {\n\t\t\t\t\trequestErrorCallback = () => {\n\t\t\t\t\t\tif (!requestErrored) {\n\t\t\t\t\t\t\trequestErrored = true;\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\tconst handler = response => {\n\t\t\t\t\tif (revalidate && !opts.forceRefresh) {\n\t\t\t\t\t\tresponse.status = response.statusCode;\n\t\t\t\t\t\tconst revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);\n\t\t\t\t\t\tif (!revalidatedPolicy.modified) {\n\t\t\t\t\t\t\tconst headers = revalidatedPolicy.policy.responseHeaders();\n\t\t\t\t\t\t\tresponse = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);\n\t\t\t\t\t\t\tresponse.cachePolicy = revalidatedPolicy.policy;\n\t\t\t\t\t\t\tresponse.fromCache = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!response.fromCache) {\n\t\t\t\t\t\tresponse.cachePolicy = new CachePolicy(opts, response, opts);\n\t\t\t\t\t\tresponse.fromCache = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet clonedResponse;\n\t\t\t\t\tif (opts.cache && response.cachePolicy.storable()) {\n\t\t\t\t\t\tclonedResponse = cloneResponse(response);\n\n\t\t\t\t\t\t(async () => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconst bodyPromise = getStream.buffer(response);\n\n\t\t\t\t\t\t\t\tawait Promise.race([\n\t\t\t\t\t\t\t\t\trequestErrorPromise,\n\t\t\t\t\t\t\t\t\tnew Promise(resolve => response.once('end', resolve))\n\t\t\t\t\t\t\t\t]);\n\n\t\t\t\t\t\t\t\tif (requestErrored) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst body = await bodyPromise;\n\n\t\t\t\t\t\t\t\tconst value = {\n\t\t\t\t\t\t\t\t\tcachePolicy: response.cachePolicy.toObject(),\n\t\t\t\t\t\t\t\t\turl: response.url,\n\t\t\t\t\t\t\t\t\tstatusCode: response.fromCache ? revalidate.statusCode : response.statusCode,\n\t\t\t\t\t\t\t\t\tbody\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tlet ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;\n\t\t\t\t\t\t\t\tif (opts.maxTtl) {\n\t\t\t\t\t\t\t\t\tttl = ttl ? Math.min(ttl, opts.maxTtl) : opts.maxTtl;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tawait this.cache.set(key, value, ttl);\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tee.emit('error', new CacheableRequest.CacheError(error));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})();\n\t\t\t\t\t} else if (opts.cache && revalidate) {\n\t\t\t\t\t\t(async () => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait this.cache.delete(key);\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tee.emit('error', new CacheableRequest.CacheError(error));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})();\n\t\t\t\t\t}\n\n\t\t\t\t\tee.emit('response', clonedResponse || response);\n\t\t\t\t\tif (typeof cb === 'function') {\n\t\t\t\t\t\tcb(clonedResponse || response);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\ttry {\n\t\t\t\t\tconst req = request(opts, handler);\n\t\t\t\t\treq.once('error', requestErrorCallback);\n\t\t\t\t\treq.once('abort', requestErrorCallback);\n\t\t\t\t\tee.emit('request', req);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tee.emit('error', new CacheableRequest.RequestError(error));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t(async () => {\n\t\t\t\tconst get = async opts => {\n\t\t\t\t\tawait Promise.resolve();\n\n\t\t\t\t\tconst cacheEntry = opts.cache ? await this.cache.get(key) : undefined;\n\t\t\t\t\tif (typeof cacheEntry === 'undefined') {\n\t\t\t\t\t\treturn makeRequest(opts);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst policy = CachePolicy.fromObject(cacheEntry.cachePolicy);\n\t\t\t\t\tif (policy.satisfiesWithoutRevalidation(opts) && !opts.forceRefresh) {\n\t\t\t\t\t\tconst headers = policy.responseHeaders();\n\t\t\t\t\t\tconst response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);\n\t\t\t\t\t\tresponse.cachePolicy = policy;\n\t\t\t\t\t\tresponse.fromCache = true;\n\n\t\t\t\t\t\tee.emit('response', response);\n\t\t\t\t\t\tif (typeof cb === 'function') {\n\t\t\t\t\t\t\tcb(response);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trevalidate = cacheEntry;\n\t\t\t\t\t\topts.headers = policy.revalidationHeaders(opts);\n\t\t\t\t\t\tmakeRequest(opts);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tconst errorHandler = error => ee.emit('error', new CacheableRequest.CacheError(error));\n\t\t\t\tthis.cache.once('error', errorHandler);\n\t\t\t\tee.on('response', () => this.cache.removeListener('error', errorHandler));\n\n\t\t\t\ttry {\n\t\t\t\t\tawait get(opts);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (opts.automaticFailover && !madeRequest) {\n\t\t\t\t\t\tmakeRequest(opts);\n\t\t\t\t\t}\n\n\t\t\t\t\tee.emit('error', new CacheableRequest.CacheError(error));\n\t\t\t\t}\n\t\t\t})();\n\n\t\t\treturn ee;\n\t\t};\n\t}\n}\n\nfunction urlObjectToRequestOptions(url) {\n\tconst options = { ...url };\n\toptions.path = `${url.pathname || '/'}${url.search || ''}`;\n\tdelete options.pathname;\n\tdelete options.search;\n\treturn options;\n}\n\nfunction normalizeUrlObject(url) {\n\t// If url was parsed by url.parse or new URL:\n\t// - hostname will be set\n\t// - host will be hostname[:port]\n\t// - port will be set if it was explicit in the parsed string\n\t// Otherwise, url was from request options:\n\t// - hostname or host may be set\n\t// - host shall not have port encoded\n\treturn {\n\t\tprotocol: url.protocol,\n\t\tauth: url.auth,\n\t\thostname: url.hostname || url.host || 'localhost',\n\t\tport: url.port,\n\t\tpathname: url.pathname,\n\t\tsearch: url.search\n\t};\n}\n\nCacheableRequest.RequestError = class extends Error {\n\tconstructor(error) {\n\t\tsuper(error.message);\n\t\tthis.name = 'RequestError';\n\t\tObject.assign(this, error);\n\t}\n};\n\nCacheableRequest.CacheError = class extends Error {\n\tconstructor(error) {\n\t\tsuper(error.message);\n\t\tthis.name = 'CacheError';\n\t\tObject.assign(this, error);\n\t}\n};\n\nmodule.exports = CacheableRequest;\n"]},"metadata":{},"sourceType":"script"}
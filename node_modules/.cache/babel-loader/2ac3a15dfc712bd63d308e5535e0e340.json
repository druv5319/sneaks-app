{"ast":null,"code":"var assert = require('assert');\n\nvar Serializer = require('./framer').Serializer;\n\nvar Deserializer = require('./framer').Deserializer;\n\nvar Compressor = require('./compressor').Compressor;\n\nvar Decompressor = require('./compressor').Decompressor;\n\nvar Connection = require('./connection').Connection;\n\nvar Duplex = require('stream').Duplex;\n\nvar Transform = require('stream').Transform;\n\nexports.Endpoint = Endpoint; // The Endpoint class\n// ==================\n// Public API\n// ----------\n// - **new Endpoint(log, role, settings, filters)**: create a new Endpoint.\n//\n//   - `log`: bunyan logger of the parent\n//   - `role`: 'CLIENT' or 'SERVER'\n//   - `settings`: initial HTTP/2 settings\n//   - `filters`: a map of functions that filter the traffic between components (for debugging or\n//     intentional failure injection).\n//\n//     Filter functions get three arguments:\n//     1. `frame`: the current frame\n//     2. `forward(frame)`: function that can be used to forward a frame to the next component\n//     3. `done()`: callback to signal the end of the filter process\n//\n//     Valid filter names and their position in the stack:\n//     - `beforeSerialization`: after compression, before serialization\n//     - `beforeCompression`: after multiplexing, before compression\n//     - `afterDeserialization`: after deserialization, before decompression\n//     - `afterDecompression`: after decompression, before multiplexing\n//\n// * **Event: 'stream' (Stream)**: 'stream' event forwarded from the underlying Connection\n//\n// * **Event: 'error' (type)**: signals an error\n//\n// * **createStream(): Stream**: initiate a new stream (forwarded to the underlying Connection)\n//\n// * **close([error])**: close the connection with an error code\n// Constructor\n// -----------\n// The process of initialization:\n\nfunction Endpoint(log, role, settings, filters) {\n  Duplex.call(this); // * Initializing logging infrastructure\n\n  this._log = log.child({\n    component: 'endpoint',\n    e: this\n  }); // * First part of the handshake process: sending and receiving the client connection header\n  //   prelude.\n\n  assert(role === 'CLIENT' || role === 'SERVER');\n\n  if (role === 'CLIENT') {\n    this._writePrelude();\n  } else {\n    this._readPrelude();\n  } // * Initialization of component. This includes the second part of the handshake process:\n  //   sending the first SETTINGS frame. This is done by the connection class right after\n  //   initialization.\n\n\n  this._initializeDataFlow(role, settings, filters || {}); // * Initialization of management code.\n\n\n  this._initializeManagement(); // * Initializing error handling.\n\n\n  this._initializeErrorHandling();\n}\n\nEndpoint.prototype = Object.create(Duplex.prototype, {\n  constructor: {\n    value: Endpoint\n  }\n}); // Handshake\n// ---------\n\nvar CLIENT_PRELUDE = new Buffer('PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n'); // Writing the client header is simple and synchronous.\n\nEndpoint.prototype._writePrelude = function _writePrelude() {\n  this._log.debug('Sending the client connection header prelude.');\n\n  this.push(CLIENT_PRELUDE);\n}; // The asynchronous process of reading the client header:\n\n\nEndpoint.prototype._readPrelude = function _readPrelude() {\n  // * progress in the header is tracker using a `cursor`\n  var cursor = 0; // * `_write` is temporarily replaced by the comparator function\n\n  this._write = function _temporalWrite(chunk, encoding, done) {\n    // * which compares the stored header with the current `chunk` byte by byte and emits the\n    //   'error' event if there's a byte that doesn't match\n    var offset = cursor;\n\n    while (cursor < CLIENT_PRELUDE.length && cursor - offset < chunk.length) {\n      if (CLIENT_PRELUDE[cursor] !== chunk[cursor - offset]) {\n        this._log.fatal({\n          cursor: cursor,\n          offset: offset,\n          chunk: chunk\n        }, 'Client connection header prelude does not match.');\n\n        this._error('handshake', 'PROTOCOL_ERROR');\n\n        return;\n      }\n\n      cursor += 1;\n    } // * if the whole header is over, and there were no error then restore the original `_write`\n    //   and call it with the remaining part of the current chunk\n\n\n    if (cursor === CLIENT_PRELUDE.length) {\n      this._log.debug('Successfully received the client connection header prelude.');\n\n      delete this._write;\n      chunk = chunk.slice(cursor - offset);\n\n      this._write(chunk, encoding, done);\n    }\n  };\n}; // Data flow\n// ---------\n//     +---------------------------------------------+\n//     |                                             |\n//     |   +-------------------------------------+   |\n//     |   | +---------+ +---------+ +---------+ |   |\n//     |   | | stream1 | | stream2 | |   ...   | |   |\n//     |   | +---------+ +---------+ +---------+ |   |\n//     |   |             connection              |   |\n//     |   +-------------------------------------+   |\n//     |             |                 ^             |\n//     |        pipe |                 | pipe        |\n//     |             v                 |             |\n//     |   +------------------+------------------+   |\n//     |   |    compressor    |   decompressor   |   |\n//     |   +------------------+------------------+   |\n//     |             |                 ^             |\n//     |        pipe |                 | pipe        |\n//     |             v                 |             |\n//     |   +------------------+------------------+   |\n//     |   |    serializer    |   deserializer   |   |\n//     |   +------------------+------------------+   |\n//     |             |                 ^             |\n//     |     _read() |                 | _write()    |\n//     |             v                 |             |\n//     |      +------------+     +-----------+       |\n//     |      |output queue|     |input queue|       |\n//     +------+------------+-----+-----------+-------+\n//                   |                 ^\n//            read() |                 | write()\n//                   v                 |\n\n\nfunction createTransformStream(filter) {\n  var transform = new Transform({\n    objectMode: true\n  });\n  var push = transform.push.bind(transform);\n\n  transform._transform = function (frame, encoding, done) {\n    filter(frame, push, done);\n  };\n\n  return transform;\n}\n\nfunction pipeAndFilter(stream1, stream2, filter) {\n  if (filter) {\n    stream1.pipe(createTransformStream(filter)).pipe(stream2);\n  } else {\n    stream1.pipe(stream2);\n  }\n}\n\nEndpoint.prototype._initializeDataFlow = function _initializeDataFlow(role, settings, filters) {\n  var firstStreamId, compressorRole, decompressorRole;\n\n  if (role === 'CLIENT') {\n    firstStreamId = 1;\n    compressorRole = 'REQUEST';\n    decompressorRole = 'RESPONSE';\n  } else {\n    firstStreamId = 2;\n    compressorRole = 'RESPONSE';\n    decompressorRole = 'REQUEST';\n  }\n\n  this._serializer = new Serializer(this._log);\n  this._deserializer = new Deserializer(this._log);\n  this._compressor = new Compressor(this._log, compressorRole);\n  this._decompressor = new Decompressor(this._log, decompressorRole);\n  this._connection = new Connection(this._log, firstStreamId, settings);\n  pipeAndFilter(this._connection, this._compressor, filters.beforeCompression);\n  pipeAndFilter(this._compressor, this._serializer, filters.beforeSerialization);\n  pipeAndFilter(this._deserializer, this._decompressor, filters.afterDeserialization);\n  pipeAndFilter(this._decompressor, this._connection, filters.afterDecompression);\n\n  this._connection.on('ACKNOWLEDGED_SETTINGS_HEADER_TABLE_SIZE', this._decompressor.setTableSizeLimit.bind(this._decompressor));\n\n  this._connection.on('RECEIVING_SETTINGS_HEADER_TABLE_SIZE', this._compressor.setTableSizeLimit.bind(this._compressor));\n};\n\nvar noread = {};\n\nEndpoint.prototype._read = function _read() {\n  this._readableState.sync = true;\n  var moreNeeded = noread,\n      chunk;\n\n  while (moreNeeded && (chunk = this._serializer.read())) {\n    moreNeeded = this.push(chunk);\n  }\n\n  if (moreNeeded === noread) {\n    this._serializer.once('readable', this._read.bind(this));\n  }\n\n  this._readableState.sync = false;\n};\n\nEndpoint.prototype._write = function _write(chunk, encoding, done) {\n  this._deserializer.write(chunk, encoding, done);\n}; // Management\n// --------------\n\n\nEndpoint.prototype._initializeManagement = function _initializeManagement() {\n  this._connection.on('stream', this.emit.bind(this, 'stream'));\n};\n\nEndpoint.prototype.createStream = function createStream() {\n  return this._connection.createStream();\n}; // Error handling\n// --------------\n\n\nEndpoint.prototype._initializeErrorHandling = function _initializeErrorHandling() {\n  this._serializer.on('error', this._error.bind(this, 'serializer'));\n\n  this._deserializer.on('error', this._error.bind(this, 'deserializer'));\n\n  this._compressor.on('error', this._error.bind(this, 'compressor'));\n\n  this._decompressor.on('error', this._error.bind(this, 'decompressor'));\n\n  this._connection.on('error', this._error.bind(this, 'connection'));\n\n  this._connection.on('peerError', this.emit.bind(this, 'peerError'));\n};\n\nEndpoint.prototype._error = function _error(component, error) {\n  this._log.fatal({\n    source: component,\n    message: error\n  }, 'Fatal error, closing connection');\n\n  this.close(error);\n  setImmediate(this.emit.bind(this, 'error', error));\n};\n\nEndpoint.prototype.close = function close(error) {\n  this._connection.close(error);\n}; // Bunyan serializers\n// ------------------\n\n\nexports.serializers = {};\nvar nextId = 0;\n\nexports.serializers.e = function (endpoint) {\n  if (!('id' in endpoint)) {\n    endpoint.id = nextId;\n    nextId += 1;\n  }\n\n  return endpoint.id;\n};","map":{"version":3,"sources":["/Users/dhruv/Sneaks/sneaks-website/node_modules/http2/lib/protocol/endpoint.js"],"names":["assert","require","Serializer","Deserializer","Compressor","Decompressor","Connection","Duplex","Transform","exports","Endpoint","log","role","settings","filters","call","_log","child","component","e","_writePrelude","_readPrelude","_initializeDataFlow","_initializeManagement","_initializeErrorHandling","prototype","Object","create","constructor","value","CLIENT_PRELUDE","Buffer","debug","push","cursor","_write","_temporalWrite","chunk","encoding","done","offset","length","fatal","_error","slice","createTransformStream","filter","transform","objectMode","bind","_transform","frame","pipeAndFilter","stream1","stream2","pipe","firstStreamId","compressorRole","decompressorRole","_serializer","_deserializer","_compressor","_decompressor","_connection","beforeCompression","beforeSerialization","afterDeserialization","afterDecompression","on","setTableSizeLimit","noread","_read","_readableState","sync","moreNeeded","read","once","write","emit","createStream","error","source","message","close","setImmediate","serializers","nextId","endpoint","id"],"mappings":"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","sourcesContent":["var assert = require('assert');\n\nvar Serializer   = require('./framer').Serializer;\nvar Deserializer = require('./framer').Deserializer;\nvar Compressor   = require('./compressor').Compressor;\nvar Decompressor = require('./compressor').Decompressor;\nvar Connection   = require('./connection').Connection;\nvar Duplex       = require('stream').Duplex;\nvar Transform    = require('stream').Transform;\n\nexports.Endpoint = Endpoint;\n\n// The Endpoint class\n// ==================\n\n// Public API\n// ----------\n\n// - **new Endpoint(log, role, settings, filters)**: create a new Endpoint.\n//\n//   - `log`: bunyan logger of the parent\n//   - `role`: 'CLIENT' or 'SERVER'\n//   - `settings`: initial HTTP/2 settings\n//   - `filters`: a map of functions that filter the traffic between components (for debugging or\n//     intentional failure injection).\n//\n//     Filter functions get three arguments:\n//     1. `frame`: the current frame\n//     2. `forward(frame)`: function that can be used to forward a frame to the next component\n//     3. `done()`: callback to signal the end of the filter process\n//\n//     Valid filter names and their position in the stack:\n//     - `beforeSerialization`: after compression, before serialization\n//     - `beforeCompression`: after multiplexing, before compression\n//     - `afterDeserialization`: after deserialization, before decompression\n//     - `afterDecompression`: after decompression, before multiplexing\n//\n// * **Event: 'stream' (Stream)**: 'stream' event forwarded from the underlying Connection\n//\n// * **Event: 'error' (type)**: signals an error\n//\n// * **createStream(): Stream**: initiate a new stream (forwarded to the underlying Connection)\n//\n// * **close([error])**: close the connection with an error code\n\n// Constructor\n// -----------\n\n// The process of initialization:\nfunction Endpoint(log, role, settings, filters) {\n  Duplex.call(this);\n\n  // * Initializing logging infrastructure\n  this._log = log.child({ component: 'endpoint', e: this });\n\n  // * First part of the handshake process: sending and receiving the client connection header\n  //   prelude.\n  assert((role === 'CLIENT') || role === 'SERVER');\n  if (role === 'CLIENT') {\n    this._writePrelude();\n  } else {\n    this._readPrelude();\n  }\n\n  // * Initialization of component. This includes the second part of the handshake process:\n  //   sending the first SETTINGS frame. This is done by the connection class right after\n  //   initialization.\n  this._initializeDataFlow(role, settings, filters || {});\n\n  // * Initialization of management code.\n  this._initializeManagement();\n\n  // * Initializing error handling.\n  this._initializeErrorHandling();\n}\nEndpoint.prototype = Object.create(Duplex.prototype, { constructor: { value: Endpoint } });\n\n// Handshake\n// ---------\n\nvar CLIENT_PRELUDE = new Buffer('PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n');\n\n// Writing the client header is simple and synchronous.\nEndpoint.prototype._writePrelude = function _writePrelude() {\n  this._log.debug('Sending the client connection header prelude.');\n  this.push(CLIENT_PRELUDE);\n};\n\n// The asynchronous process of reading the client header:\nEndpoint.prototype._readPrelude = function _readPrelude() {\n  // * progress in the header is tracker using a `cursor`\n  var cursor = 0;\n\n  // * `_write` is temporarily replaced by the comparator function\n  this._write = function _temporalWrite(chunk, encoding, done) {\n    // * which compares the stored header with the current `chunk` byte by byte and emits the\n    //   'error' event if there's a byte that doesn't match\n    var offset = cursor;\n    while(cursor < CLIENT_PRELUDE.length && (cursor - offset) < chunk.length) {\n      if (CLIENT_PRELUDE[cursor] !== chunk[cursor - offset]) {\n        this._log.fatal({ cursor: cursor, offset: offset, chunk: chunk },\n                        'Client connection header prelude does not match.');\n        this._error('handshake', 'PROTOCOL_ERROR');\n        return;\n      }\n      cursor += 1;\n    }\n\n    // * if the whole header is over, and there were no error then restore the original `_write`\n    //   and call it with the remaining part of the current chunk\n    if (cursor === CLIENT_PRELUDE.length) {\n      this._log.debug('Successfully received the client connection header prelude.');\n      delete this._write;\n      chunk = chunk.slice(cursor - offset);\n      this._write(chunk, encoding, done);\n    }\n  };\n};\n\n// Data flow\n// ---------\n\n//     +---------------------------------------------+\n//     |                                             |\n//     |   +-------------------------------------+   |\n//     |   | +---------+ +---------+ +---------+ |   |\n//     |   | | stream1 | | stream2 | |   ...   | |   |\n//     |   | +---------+ +---------+ +---------+ |   |\n//     |   |             connection              |   |\n//     |   +-------------------------------------+   |\n//     |             |                 ^             |\n//     |        pipe |                 | pipe        |\n//     |             v                 |             |\n//     |   +------------------+------------------+   |\n//     |   |    compressor    |   decompressor   |   |\n//     |   +------------------+------------------+   |\n//     |             |                 ^             |\n//     |        pipe |                 | pipe        |\n//     |             v                 |             |\n//     |   +------------------+------------------+   |\n//     |   |    serializer    |   deserializer   |   |\n//     |   +------------------+------------------+   |\n//     |             |                 ^             |\n//     |     _read() |                 | _write()    |\n//     |             v                 |             |\n//     |      +------------+     +-----------+       |\n//     |      |output queue|     |input queue|       |\n//     +------+------------+-----+-----------+-------+\n//                   |                 ^\n//            read() |                 | write()\n//                   v                 |\n\nfunction createTransformStream(filter) {\n  var transform = new Transform({ objectMode: true });\n  var push = transform.push.bind(transform);\n  transform._transform = function(frame, encoding, done) {\n    filter(frame, push, done);\n  };\n  return transform;\n}\n\nfunction pipeAndFilter(stream1, stream2, filter) {\n  if (filter) {\n    stream1.pipe(createTransformStream(filter)).pipe(stream2);\n  } else {\n    stream1.pipe(stream2);\n  }\n}\n\nEndpoint.prototype._initializeDataFlow = function _initializeDataFlow(role, settings, filters) {\n  var firstStreamId, compressorRole, decompressorRole;\n  if (role === 'CLIENT') {\n    firstStreamId = 1;\n    compressorRole = 'REQUEST';\n    decompressorRole = 'RESPONSE';\n  } else {\n    firstStreamId = 2;\n    compressorRole = 'RESPONSE';\n    decompressorRole = 'REQUEST';\n  }\n\n  this._serializer   = new Serializer(this._log);\n  this._deserializer = new Deserializer(this._log);\n  this._compressor   = new Compressor(this._log, compressorRole);\n  this._decompressor = new Decompressor(this._log, decompressorRole);\n  this._connection   = new Connection(this._log, firstStreamId, settings);\n\n  pipeAndFilter(this._connection, this._compressor, filters.beforeCompression);\n  pipeAndFilter(this._compressor, this._serializer, filters.beforeSerialization);\n  pipeAndFilter(this._deserializer, this._decompressor, filters.afterDeserialization);\n  pipeAndFilter(this._decompressor, this._connection, filters.afterDecompression);\n\n  this._connection.on('ACKNOWLEDGED_SETTINGS_HEADER_TABLE_SIZE',\n                      this._decompressor.setTableSizeLimit.bind(this._decompressor));\n  this._connection.on('RECEIVING_SETTINGS_HEADER_TABLE_SIZE',\n                      this._compressor.setTableSizeLimit.bind(this._compressor));\n};\n\nvar noread = {};\nEndpoint.prototype._read = function _read() {\n  this._readableState.sync = true;\n  var moreNeeded = noread, chunk;\n  while (moreNeeded && (chunk = this._serializer.read())) {\n    moreNeeded = this.push(chunk);\n  }\n  if (moreNeeded === noread) {\n    this._serializer.once('readable', this._read.bind(this));\n  }\n  this._readableState.sync = false;\n};\n\nEndpoint.prototype._write = function _write(chunk, encoding, done) {\n  this._deserializer.write(chunk, encoding, done);\n};\n\n// Management\n// --------------\n\nEndpoint.prototype._initializeManagement = function _initializeManagement() {\n  this._connection.on('stream', this.emit.bind(this, 'stream'));\n};\n\nEndpoint.prototype.createStream = function createStream() {\n  return this._connection.createStream();\n};\n\n// Error handling\n// --------------\n\nEndpoint.prototype._initializeErrorHandling = function _initializeErrorHandling() {\n  this._serializer.on('error', this._error.bind(this, 'serializer'));\n  this._deserializer.on('error', this._error.bind(this, 'deserializer'));\n  this._compressor.on('error', this._error.bind(this, 'compressor'));\n  this._decompressor.on('error', this._error.bind(this, 'decompressor'));\n  this._connection.on('error', this._error.bind(this, 'connection'));\n\n  this._connection.on('peerError', this.emit.bind(this, 'peerError'));\n};\n\nEndpoint.prototype._error = function _error(component, error) {\n  this._log.fatal({ source: component, message: error }, 'Fatal error, closing connection');\n  this.close(error);\n  setImmediate(this.emit.bind(this, 'error', error));\n};\n\nEndpoint.prototype.close = function close(error) {\n  this._connection.close(error);\n};\n\n// Bunyan serializers\n// ------------------\n\nexports.serializers = {};\n\nvar nextId = 0;\nexports.serializers.e = function(endpoint) {\n  if (!('id' in endpoint)) {\n    endpoint.id = nextId;\n    nextId += 1;\n  }\n  return endpoint.id;\n};\n"]},"metadata":{},"sourceType":"script"}
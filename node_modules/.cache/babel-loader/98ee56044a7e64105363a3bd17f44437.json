{"ast":null,"code":"var path = require('path');\n\nvar fs = require('fs');\n\nfunction Mime() {\n  // Map of extension -> mime type\n  this.types = Object.create(null); // Map of mime type -> extension\n\n  this.extensions = Object.create(null);\n}\n/**\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * @param map (Object) type definitions\n */\n\n\nMime.prototype.define = function (map) {\n  for (var type in map) {\n    var exts = map[type];\n\n    for (var i = 0; i < exts.length; i++) {\n      if (process.env.DEBUG_MIME && this.types[exts[i]]) {\n        console.warn((this._loading || \"define()\").replace(/.*\\//, ''), 'changes \"' + exts[i] + '\" extension type from ' + this.types[exts[i]] + ' to ' + type);\n      }\n\n      this.types[exts[i]] = type;\n    } // Default extension is the first one we encounter\n\n\n    if (!this.extensions[type]) {\n      this.extensions[type] = exts[0];\n    }\n  }\n};\n/**\n * Load an Apache2-style \".types\" file\n *\n * This may be called multiple times (it's expected).  Where files declare\n * overlapping types/extensions, the last file wins.\n *\n * @param file (String) path of file to load.\n */\n\n\nMime.prototype.load = function (file) {\n  this._loading = file; // Read file and split into lines\n\n  var map = {},\n      content = fs.readFileSync(file, 'ascii'),\n      lines = content.split(/[\\r\\n]+/);\n  lines.forEach(function (line) {\n    // Clean up whitespace/comments, and split into fields\n    var fields = line.replace(/\\s*#.*|^\\s*|\\s*$/g, '').split(/\\s+/);\n    map[fields.shift()] = fields;\n  });\n  this.define(map);\n  this._loading = null;\n};\n/**\n * Lookup a mime type based on extension\n */\n\n\nMime.prototype.lookup = function (path, fallback) {\n  var ext = path.replace(/^.*[\\.\\/\\\\]/, '').toLowerCase();\n  return this.types[ext] || fallback || this.default_type;\n};\n/**\n * Return file extension associated with a mime type\n */\n\n\nMime.prototype.extension = function (mimeType) {\n  var type = mimeType.match(/^\\s*([^;\\s]*)(?:;|\\s|$)/)[1].toLowerCase();\n  return this.extensions[type];\n}; // Default instance\n\n\nvar mime = new Mime(); // Define built-in types\n\nmime.define(require('./types.json')); // Default type\n\nmime.default_type = mime.lookup('bin'); //\n// Additional API specific to the default instance\n//\n\nmime.Mime = Mime;\n/**\n * Lookup a charset based on mime type.\n */\n\nmime.charsets = {\n  lookup: function (mimeType, fallback) {\n    // Assume text types are utf8\n    return /^text\\/|^application\\/(javascript|json)/.test(mimeType) ? 'UTF-8' : fallback;\n  }\n};\nmodule.exports = mime;","map":{"version":3,"sources":["/Users/dhruv/Sneaks/sneaks-website/node_modules/send/node_modules/mime/mime.js"],"names":["path","require","fs","Mime","types","Object","create","extensions","prototype","define","map","type","exts","i","length","process","env","DEBUG_MIME","console","warn","_loading","replace","load","file","content","readFileSync","lines","split","forEach","line","fields","shift","lookup","fallback","ext","toLowerCase","default_type","extension","mimeType","match","mime","charsets","test","module","exports"],"mappings":"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","sourcesContent":["var path = require('path');\nvar fs = require('fs');\n\nfunction Mime() {\n  // Map of extension -> mime type\n  this.types = Object.create(null);\n\n  // Map of mime type -> extension\n  this.extensions = Object.create(null);\n}\n\n/**\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * @param map (Object) type definitions\n */\nMime.prototype.define = function (map) {\n  for (var type in map) {\n    var exts = map[type];\n    for (var i = 0; i < exts.length; i++) {\n      if (process.env.DEBUG_MIME && this.types[exts[i]]) {\n        console.warn((this._loading || \"define()\").replace(/.*\\//, ''), 'changes \"' + exts[i] + '\" extension type from ' +\n          this.types[exts[i]] + ' to ' + type);\n      }\n\n      this.types[exts[i]] = type;\n    }\n\n    // Default extension is the first one we encounter\n    if (!this.extensions[type]) {\n      this.extensions[type] = exts[0];\n    }\n  }\n};\n\n/**\n * Load an Apache2-style \".types\" file\n *\n * This may be called multiple times (it's expected).  Where files declare\n * overlapping types/extensions, the last file wins.\n *\n * @param file (String) path of file to load.\n */\nMime.prototype.load = function(file) {\n  this._loading = file;\n  // Read file and split into lines\n  var map = {},\n      content = fs.readFileSync(file, 'ascii'),\n      lines = content.split(/[\\r\\n]+/);\n\n  lines.forEach(function(line) {\n    // Clean up whitespace/comments, and split into fields\n    var fields = line.replace(/\\s*#.*|^\\s*|\\s*$/g, '').split(/\\s+/);\n    map[fields.shift()] = fields;\n  });\n\n  this.define(map);\n\n  this._loading = null;\n};\n\n/**\n * Lookup a mime type based on extension\n */\nMime.prototype.lookup = function(path, fallback) {\n  var ext = path.replace(/^.*[\\.\\/\\\\]/, '').toLowerCase();\n\n  return this.types[ext] || fallback || this.default_type;\n};\n\n/**\n * Return file extension associated with a mime type\n */\nMime.prototype.extension = function(mimeType) {\n  var type = mimeType.match(/^\\s*([^;\\s]*)(?:;|\\s|$)/)[1].toLowerCase();\n  return this.extensions[type];\n};\n\n// Default instance\nvar mime = new Mime();\n\n// Define built-in types\nmime.define(require('./types.json'));\n\n// Default type\nmime.default_type = mime.lookup('bin');\n\n//\n// Additional API specific to the default instance\n//\n\nmime.Mime = Mime;\n\n/**\n * Lookup a charset based on mime type.\n */\nmime.charsets = {\n  lookup: function(mimeType, fallback) {\n    // Assume text types are utf8\n    return (/^text\\/|^application\\/(javascript|json)/).test(mimeType) ? 'UTF-8' : fallback;\n  }\n};\n\nmodule.exports = mime;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"/*!\n * on-finished\n * Copyright(c) 2013 Jonathan Ong\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = onFinished;\nmodule.exports.isFinished = isFinished;\n/**\n * Module dependencies.\n * @private\n */\n\nvar first = require('ee-first');\n/**\n * Variables.\n * @private\n */\n\n/* istanbul ignore next */\n\n\nvar defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {\n  process.nextTick(fn.bind.apply(fn, arguments));\n};\n/**\n * Invoke callback when the response has finished, useful for\n * cleaning up resources afterwards.\n *\n * @param {object} msg\n * @param {function} listener\n * @return {object}\n * @public\n */\n\nfunction onFinished(msg, listener) {\n  if (isFinished(msg) !== false) {\n    defer(listener, null, msg);\n    return msg;\n  } // attach the listener to the message\n\n\n  attachListener(msg, listener);\n  return msg;\n}\n/**\n * Determine if message is already finished.\n *\n * @param {object} msg\n * @return {boolean}\n * @public\n */\n\n\nfunction isFinished(msg) {\n  var socket = msg.socket;\n\n  if (typeof msg.finished === 'boolean') {\n    // OutgoingMessage\n    return Boolean(msg.finished || socket && !socket.writable);\n  }\n\n  if (typeof msg.complete === 'boolean') {\n    // IncomingMessage\n    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);\n  } // don't know\n\n\n  return undefined;\n}\n/**\n * Attach a finished listener to the message.\n *\n * @param {object} msg\n * @param {function} callback\n * @private\n */\n\n\nfunction attachFinishedListener(msg, callback) {\n  var eeMsg;\n  var eeSocket;\n  var finished = false;\n\n  function onFinish(error) {\n    eeMsg.cancel();\n    eeSocket.cancel();\n    finished = true;\n    callback(error);\n  } // finished on first message event\n\n\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);\n\n  function onSocket(socket) {\n    // remove listener\n    msg.removeListener('socket', onSocket);\n    if (finished) return;\n    if (eeMsg !== eeSocket) return; // finished on first socket event\n\n    eeSocket = first([[socket, 'error', 'close']], onFinish);\n  }\n\n  if (msg.socket) {\n    // socket already assigned\n    onSocket(msg.socket);\n    return;\n  } // wait for socket to be assigned\n\n\n  msg.on('socket', onSocket);\n\n  if (msg.socket === undefined) {\n    // node.js 0.8 patch\n    patchAssignSocket(msg, onSocket);\n  }\n}\n/**\n * Attach the listener to the message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\n\nfunction attachListener(msg, listener) {\n  var attached = msg.__onFinished; // create a private single listener with queue\n\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = createListener(msg);\n    attachFinishedListener(msg, attached);\n  }\n\n  attached.queue.push(listener);\n}\n/**\n * Create listener on message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\n\nfunction createListener(msg) {\n  function listener(err) {\n    if (msg.__onFinished === listener) msg.__onFinished = null;\n    if (!listener.queue) return;\n    var queue = listener.queue;\n    listener.queue = null;\n\n    for (var i = 0; i < queue.length; i++) {\n      queue[i](err, msg);\n    }\n  }\n\n  listener.queue = [];\n  return listener;\n}\n/**\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\n *\n * @param {ServerResponse} res\n * @param {function} callback\n * @private\n */\n\n\nfunction patchAssignSocket(res, callback) {\n  var assignSocket = res.assignSocket;\n  if (typeof assignSocket !== 'function') return; // res.on('socket', callback) is broken in 0.8\n\n  res.assignSocket = function _assignSocket(socket) {\n    assignSocket.call(this, socket);\n    callback(socket);\n  };\n}","map":{"version":3,"sources":["/Users/dhruv/Sneaks/sneaks-website/node_modules/on-finished/index.js"],"names":["module","exports","onFinished","isFinished","first","require","defer","setImmediate","fn","process","nextTick","bind","apply","arguments","msg","listener","attachListener","socket","finished","Boolean","writable","complete","upgrade","readable","undefined","attachFinishedListener","callback","eeMsg","eeSocket","onFinish","error","cancel","onSocket","removeListener","on","patchAssignSocket","attached","__onFinished","queue","createListener","push","err","i","length","res","assignSocket","_assignSocket","call"],"mappings":"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","sourcesContent":["/*!\n * on-finished\n * Copyright(c) 2013 Jonathan Ong\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = onFinished\nmodule.exports.isFinished = isFinished\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar first = require('ee-first')\n\n/**\n * Variables.\n * @private\n */\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function'\n  ? setImmediate\n  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }\n\n/**\n * Invoke callback when the response has finished, useful for\n * cleaning up resources afterwards.\n *\n * @param {object} msg\n * @param {function} listener\n * @return {object}\n * @public\n */\n\nfunction onFinished(msg, listener) {\n  if (isFinished(msg) !== false) {\n    defer(listener, null, msg)\n    return msg\n  }\n\n  // attach the listener to the message\n  attachListener(msg, listener)\n\n  return msg\n}\n\n/**\n * Determine if message is already finished.\n *\n * @param {object} msg\n * @return {boolean}\n * @public\n */\n\nfunction isFinished(msg) {\n  var socket = msg.socket\n\n  if (typeof msg.finished === 'boolean') {\n    // OutgoingMessage\n    return Boolean(msg.finished || (socket && !socket.writable))\n  }\n\n  if (typeof msg.complete === 'boolean') {\n    // IncomingMessage\n    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))\n  }\n\n  // don't know\n  return undefined\n}\n\n/**\n * Attach a finished listener to the message.\n *\n * @param {object} msg\n * @param {function} callback\n * @private\n */\n\nfunction attachFinishedListener(msg, callback) {\n  var eeMsg\n  var eeSocket\n  var finished = false\n\n  function onFinish(error) {\n    eeMsg.cancel()\n    eeSocket.cancel()\n\n    finished = true\n    callback(error)\n  }\n\n  // finished on first message event\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)\n\n  function onSocket(socket) {\n    // remove listener\n    msg.removeListener('socket', onSocket)\n\n    if (finished) return\n    if (eeMsg !== eeSocket) return\n\n    // finished on first socket event\n    eeSocket = first([[socket, 'error', 'close']], onFinish)\n  }\n\n  if (msg.socket) {\n    // socket already assigned\n    onSocket(msg.socket)\n    return\n  }\n\n  // wait for socket to be assigned\n  msg.on('socket', onSocket)\n\n  if (msg.socket === undefined) {\n    // node.js 0.8 patch\n    patchAssignSocket(msg, onSocket)\n  }\n}\n\n/**\n * Attach the listener to the message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction attachListener(msg, listener) {\n  var attached = msg.__onFinished\n\n  // create a private single listener with queue\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = createListener(msg)\n    attachFinishedListener(msg, attached)\n  }\n\n  attached.queue.push(listener)\n}\n\n/**\n * Create listener on message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction createListener(msg) {\n  function listener(err) {\n    if (msg.__onFinished === listener) msg.__onFinished = null\n    if (!listener.queue) return\n\n    var queue = listener.queue\n    listener.queue = null\n\n    for (var i = 0; i < queue.length; i++) {\n      queue[i](err, msg)\n    }\n  }\n\n  listener.queue = []\n\n  return listener\n}\n\n/**\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\n *\n * @param {ServerResponse} res\n * @param {function} callback\n * @private\n */\n\nfunction patchAssignSocket(res, callback) {\n  var assignSocket = res.assignSocket\n\n  if (typeof assignSocket !== 'function') return\n\n  // res.on('socket', callback) is broken in 0.8\n  res.assignSocket = function _assignSocket(socket) {\n    assignSocket.call(this, socket)\n    callback(socket)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
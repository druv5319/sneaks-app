{"ast":null,"code":"/*!\n * raw-body\n * Copyright(c) 2013-2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes');\n\nvar createError = require('http-errors');\n\nvar iconv = require('iconv-lite');\n\nvar unpipe = require('unpipe');\n/**\n * Module exports.\n * @public\n */\n\n\nmodule.exports = getRawBody;\n/**\n * Module variables.\n * @private\n */\n\nvar ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;\n/**\n * Get the decoder for a given encoding.\n *\n * @param {string} encoding\n * @private\n */\n\nfunction getDecoder(encoding) {\n  if (!encoding) return null;\n\n  try {\n    return iconv.getDecoder(encoding);\n  } catch (e) {\n    // error getting decoder\n    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e; // the encoding was not found\n\n    throw createError(415, 'specified encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    });\n  }\n}\n/**\n * Get the raw body of a stream (typically HTTP).\n *\n * @param {object} stream\n * @param {object|string|function} [options]\n * @param {function} [callback]\n * @public\n */\n\n\nfunction getRawBody(stream, options, callback) {\n  var done = callback;\n  var opts = options || {};\n\n  if (options === true || typeof options === 'string') {\n    // short cut for encoding\n    opts = {\n      encoding: options\n    };\n  }\n\n  if (typeof options === 'function') {\n    done = options;\n    opts = {};\n  } // validate callback is a function, if provided\n\n\n  if (done !== undefined && typeof done !== 'function') {\n    throw new TypeError('argument callback must be a function');\n  } // require the callback without promises\n\n\n  if (!done && !global.Promise) {\n    throw new TypeError('argument callback is required');\n  } // get encoding\n\n\n  var encoding = opts.encoding !== true ? opts.encoding : 'utf-8'; // convert the limit to an integer\n\n  var limit = bytes.parse(opts.limit); // convert the expected length to an integer\n\n  var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;\n\n  if (done) {\n    // classic callback style\n    return readStream(stream, encoding, length, limit, done);\n  }\n\n  return new Promise(function executor(resolve, reject) {\n    readStream(stream, encoding, length, limit, function onRead(err, buf) {\n      if (err) return reject(err);\n      resolve(buf);\n    });\n  });\n}\n/**\n * Halt a stream.\n *\n * @param {Object} stream\n * @private\n */\n\n\nfunction halt(stream) {\n  // unpipe everything from the stream\n  unpipe(stream); // pause stream\n\n  if (typeof stream.pause === 'function') {\n    stream.pause();\n  }\n}\n/**\n * Read the data from the stream.\n *\n * @param {object} stream\n * @param {string} encoding\n * @param {number} length\n * @param {number} limit\n * @param {function} callback\n * @public\n */\n\n\nfunction readStream(stream, encoding, length, limit, callback) {\n  var complete = false;\n  var sync = true; // check the length and limit options.\n  // note: we intentionally leave the stream paused,\n  // so users should handle the stream themselves.\n\n  if (limit !== null && length !== null && length > limit) {\n    return done(createError(413, 'request entity too large', {\n      expected: length,\n      length: length,\n      limit: limit,\n      type: 'entity.too.large'\n    }));\n  } // streams1: assert request encoding is buffer.\n  // streams2+: assert the stream encoding is buffer.\n  //   stream._decoder: streams1\n  //   state.encoding: streams2\n  //   state.decoder: streams2, specifically < 0.10.6\n\n\n  var state = stream._readableState;\n\n  if (stream._decoder || state && (state.encoding || state.decoder)) {\n    // developer error\n    return done(createError(500, 'stream encoding should not be set', {\n      type: 'stream.encoding.set'\n    }));\n  }\n\n  var received = 0;\n  var decoder;\n\n  try {\n    decoder = getDecoder(encoding);\n  } catch (err) {\n    return done(err);\n  }\n\n  var buffer = decoder ? '' : []; // attach listeners\n\n  stream.on('aborted', onAborted);\n  stream.on('close', cleanup);\n  stream.on('data', onData);\n  stream.on('end', onEnd);\n  stream.on('error', onEnd); // mark sync section complete\n\n  sync = false;\n\n  function done() {\n    var args = new Array(arguments.length); // copy arguments\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    } // mark complete\n\n\n    complete = true;\n\n    if (sync) {\n      process.nextTick(invokeCallback);\n    } else {\n      invokeCallback();\n    }\n\n    function invokeCallback() {\n      cleanup();\n\n      if (args[0]) {\n        // halt the stream on error\n        halt(stream);\n      }\n\n      callback.apply(null, args);\n    }\n  }\n\n  function onAborted() {\n    if (complete) return;\n    done(createError(400, 'request aborted', {\n      code: 'ECONNABORTED',\n      expected: length,\n      length: length,\n      received: received,\n      type: 'request.aborted'\n    }));\n  }\n\n  function onData(chunk) {\n    if (complete) return;\n    received += chunk.length;\n\n    if (limit !== null && received > limit) {\n      done(createError(413, 'request entity too large', {\n        limit: limit,\n        received: received,\n        type: 'entity.too.large'\n      }));\n    } else if (decoder) {\n      buffer += decoder.write(chunk);\n    } else {\n      buffer.push(chunk);\n    }\n  }\n\n  function onEnd(err) {\n    if (complete) return;\n    if (err) return done(err);\n\n    if (length !== null && received !== length) {\n      done(createError(400, 'request size did not match content length', {\n        expected: length,\n        length: length,\n        received: received,\n        type: 'request.size.invalid'\n      }));\n    } else {\n      var string = decoder ? buffer + (decoder.end() || '') : Buffer.concat(buffer);\n      done(null, string);\n    }\n  }\n\n  function cleanup() {\n    buffer = null;\n    stream.removeListener('aborted', onAborted);\n    stream.removeListener('data', onData);\n    stream.removeListener('end', onEnd);\n    stream.removeListener('error', onEnd);\n    stream.removeListener('close', cleanup);\n  }\n}","map":{"version":3,"sources":["/Users/dhruv/Sneaks/sneaks-website/node_modules/raw-body/index.js"],"names":["bytes","require","createError","iconv","unpipe","module","exports","getRawBody","ICONV_ENCODING_MESSAGE_REGEXP","getDecoder","encoding","e","test","message","type","stream","options","callback","done","opts","undefined","TypeError","global","Promise","limit","parse","length","isNaN","parseInt","readStream","executor","resolve","reject","onRead","err","buf","halt","pause","complete","sync","expected","state","_readableState","_decoder","decoder","received","buffer","on","onAborted","cleanup","onData","onEnd","args","Array","arguments","i","process","nextTick","invokeCallback","apply","code","chunk","write","push","string","end","Buffer","concat","removeListener"],"mappings":"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","sourcesContent":["/*!\n * raw-body\n * Copyright(c) 2013-2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar createError = require('http-errors')\nvar iconv = require('iconv-lite')\nvar unpipe = require('unpipe')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = getRawBody\n\n/**\n * Module variables.\n * @private\n */\n\nvar ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /\n\n/**\n * Get the decoder for a given encoding.\n *\n * @param {string} encoding\n * @private\n */\n\nfunction getDecoder (encoding) {\n  if (!encoding) return null\n\n  try {\n    return iconv.getDecoder(encoding)\n  } catch (e) {\n    // error getting decoder\n    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e\n\n    // the encoding was not found\n    throw createError(415, 'specified encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    })\n  }\n}\n\n/**\n * Get the raw body of a stream (typically HTTP).\n *\n * @param {object} stream\n * @param {object|string|function} [options]\n * @param {function} [callback]\n * @public\n */\n\nfunction getRawBody (stream, options, callback) {\n  var done = callback\n  var opts = options || {}\n\n  if (options === true || typeof options === 'string') {\n    // short cut for encoding\n    opts = {\n      encoding: options\n    }\n  }\n\n  if (typeof options === 'function') {\n    done = options\n    opts = {}\n  }\n\n  // validate callback is a function, if provided\n  if (done !== undefined && typeof done !== 'function') {\n    throw new TypeError('argument callback must be a function')\n  }\n\n  // require the callback without promises\n  if (!done && !global.Promise) {\n    throw new TypeError('argument callback is required')\n  }\n\n  // get encoding\n  var encoding = opts.encoding !== true\n    ? opts.encoding\n    : 'utf-8'\n\n  // convert the limit to an integer\n  var limit = bytes.parse(opts.limit)\n\n  // convert the expected length to an integer\n  var length = opts.length != null && !isNaN(opts.length)\n    ? parseInt(opts.length, 10)\n    : null\n\n  if (done) {\n    // classic callback style\n    return readStream(stream, encoding, length, limit, done)\n  }\n\n  return new Promise(function executor (resolve, reject) {\n    readStream(stream, encoding, length, limit, function onRead (err, buf) {\n      if (err) return reject(err)\n      resolve(buf)\n    })\n  })\n}\n\n/**\n * Halt a stream.\n *\n * @param {Object} stream\n * @private\n */\n\nfunction halt (stream) {\n  // unpipe everything from the stream\n  unpipe(stream)\n\n  // pause stream\n  if (typeof stream.pause === 'function') {\n    stream.pause()\n  }\n}\n\n/**\n * Read the data from the stream.\n *\n * @param {object} stream\n * @param {string} encoding\n * @param {number} length\n * @param {number} limit\n * @param {function} callback\n * @public\n */\n\nfunction readStream (stream, encoding, length, limit, callback) {\n  var complete = false\n  var sync = true\n\n  // check the length and limit options.\n  // note: we intentionally leave the stream paused,\n  // so users should handle the stream themselves.\n  if (limit !== null && length !== null && length > limit) {\n    return done(createError(413, 'request entity too large', {\n      expected: length,\n      length: length,\n      limit: limit,\n      type: 'entity.too.large'\n    }))\n  }\n\n  // streams1: assert request encoding is buffer.\n  // streams2+: assert the stream encoding is buffer.\n  //   stream._decoder: streams1\n  //   state.encoding: streams2\n  //   state.decoder: streams2, specifically < 0.10.6\n  var state = stream._readableState\n  if (stream._decoder || (state && (state.encoding || state.decoder))) {\n    // developer error\n    return done(createError(500, 'stream encoding should not be set', {\n      type: 'stream.encoding.set'\n    }))\n  }\n\n  var received = 0\n  var decoder\n\n  try {\n    decoder = getDecoder(encoding)\n  } catch (err) {\n    return done(err)\n  }\n\n  var buffer = decoder\n    ? ''\n    : []\n\n  // attach listeners\n  stream.on('aborted', onAborted)\n  stream.on('close', cleanup)\n  stream.on('data', onData)\n  stream.on('end', onEnd)\n  stream.on('error', onEnd)\n\n  // mark sync section complete\n  sync = false\n\n  function done () {\n    var args = new Array(arguments.length)\n\n    // copy arguments\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n\n    // mark complete\n    complete = true\n\n    if (sync) {\n      process.nextTick(invokeCallback)\n    } else {\n      invokeCallback()\n    }\n\n    function invokeCallback () {\n      cleanup()\n\n      if (args[0]) {\n        // halt the stream on error\n        halt(stream)\n      }\n\n      callback.apply(null, args)\n    }\n  }\n\n  function onAborted () {\n    if (complete) return\n\n    done(createError(400, 'request aborted', {\n      code: 'ECONNABORTED',\n      expected: length,\n      length: length,\n      received: received,\n      type: 'request.aborted'\n    }))\n  }\n\n  function onData (chunk) {\n    if (complete) return\n\n    received += chunk.length\n\n    if (limit !== null && received > limit) {\n      done(createError(413, 'request entity too large', {\n        limit: limit,\n        received: received,\n        type: 'entity.too.large'\n      }))\n    } else if (decoder) {\n      buffer += decoder.write(chunk)\n    } else {\n      buffer.push(chunk)\n    }\n  }\n\n  function onEnd (err) {\n    if (complete) return\n    if (err) return done(err)\n\n    if (length !== null && received !== length) {\n      done(createError(400, 'request size did not match content length', {\n        expected: length,\n        length: length,\n        received: received,\n        type: 'request.size.invalid'\n      }))\n    } else {\n      var string = decoder\n        ? buffer + (decoder.end() || '')\n        : Buffer.concat(buffer)\n      done(null, string)\n    }\n  }\n\n  function cleanup () {\n    buffer = null\n\n    stream.removeListener('aborted', onAborted)\n    stream.removeListener('data', onData)\n    stream.removeListener('end', onEnd)\n    stream.removeListener('error', onEnd)\n    stream.removeListener('close', cleanup)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
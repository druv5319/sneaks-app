{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TimeoutError = void 0;\n\nconst net = require(\"net\");\n\nconst unhandle_1 = require(\"./unhandle\");\n\nconst reentry = Symbol('reentry');\n\nconst noop = () => {};\n\nclass TimeoutError extends Error {\n  constructor(threshold, event) {\n    super(`Timeout awaiting '${event}' for ${threshold}ms`);\n    this.event = event;\n    this.name = 'TimeoutError';\n    this.code = 'ETIMEDOUT';\n  }\n\n}\n\nexports.TimeoutError = TimeoutError;\n\nexports.default = (request, delays, options) => {\n  if (reentry in request) {\n    return noop;\n  }\n\n  request[reentry] = true;\n  const cancelers = [];\n  const {\n    once,\n    unhandleAll\n  } = unhandle_1.default();\n\n  const addTimeout = (delay, callback, event) => {\n    var _a;\n\n    const timeout = setTimeout(callback, delay, delay, event);\n    (_a = timeout.unref) === null || _a === void 0 ? void 0 : _a.call(timeout);\n\n    const cancel = () => {\n      clearTimeout(timeout);\n    };\n\n    cancelers.push(cancel);\n    return cancel;\n  };\n\n  const {\n    host,\n    hostname\n  } = options;\n\n  const timeoutHandler = (delay, event) => {\n    request.destroy(new TimeoutError(delay, event));\n  };\n\n  const cancelTimeouts = () => {\n    for (const cancel of cancelers) {\n      cancel();\n    }\n\n    unhandleAll();\n  };\n\n  request.once('error', error => {\n    cancelTimeouts(); // Save original behavior\n\n    /* istanbul ignore next */\n\n    if (request.listenerCount('error') === 0) {\n      throw error;\n    }\n  });\n  request.once('close', cancelTimeouts);\n  once(request, 'response', response => {\n    once(response, 'end', cancelTimeouts);\n  });\n\n  if (typeof delays.request !== 'undefined') {\n    addTimeout(delays.request, timeoutHandler, 'request');\n  }\n\n  if (typeof delays.socket !== 'undefined') {\n    const socketTimeoutHandler = () => {\n      timeoutHandler(delays.socket, 'socket');\n    };\n\n    request.setTimeout(delays.socket, socketTimeoutHandler); // `request.setTimeout(0)` causes a memory leak.\n    // We can just remove the listener and forget about the timer - it's unreffed.\n    // See https://github.com/sindresorhus/got/issues/690\n\n    cancelers.push(() => {\n      request.removeListener('timeout', socketTimeoutHandler);\n    });\n  }\n\n  once(request, 'socket', socket => {\n    var _a;\n\n    const {\n      socketPath\n    } = request;\n    /* istanbul ignore next: hard to test */\n\n    if (socket.connecting) {\n      const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a !== void 0 ? _a : '') !== 0);\n\n      if (typeof delays.lookup !== 'undefined' && !hasPath && typeof socket.address().address === 'undefined') {\n        const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n        once(socket, 'lookup', cancelTimeout);\n      }\n\n      if (typeof delays.connect !== 'undefined') {\n        const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n\n        if (hasPath) {\n          once(socket, 'connect', timeConnect());\n        } else {\n          once(socket, 'lookup', error => {\n            if (error === null) {\n              once(socket, 'connect', timeConnect());\n            }\n          });\n        }\n      }\n\n      if (typeof delays.secureConnect !== 'undefined' && options.protocol === 'https:') {\n        once(socket, 'connect', () => {\n          const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n          once(socket, 'secureConnect', cancelTimeout);\n        });\n      }\n    }\n\n    if (typeof delays.send !== 'undefined') {\n      const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n      /* istanbul ignore next: hard to test */\n\n\n      if (socket.connecting) {\n        once(socket, 'connect', () => {\n          once(request, 'upload-complete', timeRequest());\n        });\n      } else {\n        once(request, 'upload-complete', timeRequest());\n      }\n    }\n  });\n\n  if (typeof delays.response !== 'undefined') {\n    once(request, 'upload-complete', () => {\n      const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n      once(request, 'response', cancelTimeout);\n    });\n  }\n\n  return cancelTimeouts;\n};","map":{"version":3,"sources":["/Users/dhruv/Sneaks/sneaks-website/node_modules/got/dist/source/core/utils/timed-out.js"],"names":["Object","defineProperty","exports","value","TimeoutError","net","require","unhandle_1","reentry","Symbol","noop","Error","constructor","threshold","event","name","code","default","request","delays","options","cancelers","once","unhandleAll","addTimeout","delay","callback","_a","timeout","setTimeout","unref","call","cancel","clearTimeout","push","host","hostname","timeoutHandler","destroy","cancelTimeouts","error","listenerCount","response","socket","socketTimeoutHandler","removeListener","socketPath","connecting","hasPath","Boolean","isIP","lookup","address","cancelTimeout","connect","timeConnect","secureConnect","protocol","send","timeRequest"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TimeoutError = void 0;\nconst net = require(\"net\");\nconst unhandle_1 = require(\"./unhandle\");\nconst reentry = Symbol('reentry');\nconst noop = () => { };\nclass TimeoutError extends Error {\n    constructor(threshold, event) {\n        super(`Timeout awaiting '${event}' for ${threshold}ms`);\n        this.event = event;\n        this.name = 'TimeoutError';\n        this.code = 'ETIMEDOUT';\n    }\n}\nexports.TimeoutError = TimeoutError;\nexports.default = (request, delays, options) => {\n    if (reentry in request) {\n        return noop;\n    }\n    request[reentry] = true;\n    const cancelers = [];\n    const { once, unhandleAll } = unhandle_1.default();\n    const addTimeout = (delay, callback, event) => {\n        var _a;\n        const timeout = setTimeout(callback, delay, delay, event);\n        (_a = timeout.unref) === null || _a === void 0 ? void 0 : _a.call(timeout);\n        const cancel = () => {\n            clearTimeout(timeout);\n        };\n        cancelers.push(cancel);\n        return cancel;\n    };\n    const { host, hostname } = options;\n    const timeoutHandler = (delay, event) => {\n        request.destroy(new TimeoutError(delay, event));\n    };\n    const cancelTimeouts = () => {\n        for (const cancel of cancelers) {\n            cancel();\n        }\n        unhandleAll();\n    };\n    request.once('error', error => {\n        cancelTimeouts();\n        // Save original behavior\n        /* istanbul ignore next */\n        if (request.listenerCount('error') === 0) {\n            throw error;\n        }\n    });\n    request.once('close', cancelTimeouts);\n    once(request, 'response', (response) => {\n        once(response, 'end', cancelTimeouts);\n    });\n    if (typeof delays.request !== 'undefined') {\n        addTimeout(delays.request, timeoutHandler, 'request');\n    }\n    if (typeof delays.socket !== 'undefined') {\n        const socketTimeoutHandler = () => {\n            timeoutHandler(delays.socket, 'socket');\n        };\n        request.setTimeout(delays.socket, socketTimeoutHandler);\n        // `request.setTimeout(0)` causes a memory leak.\n        // We can just remove the listener and forget about the timer - it's unreffed.\n        // See https://github.com/sindresorhus/got/issues/690\n        cancelers.push(() => {\n            request.removeListener('timeout', socketTimeoutHandler);\n        });\n    }\n    once(request, 'socket', (socket) => {\n        var _a;\n        const { socketPath } = request;\n        /* istanbul ignore next: hard to test */\n        if (socket.connecting) {\n            const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a !== void 0 ? _a : '') !== 0);\n            if (typeof delays.lookup !== 'undefined' && !hasPath && typeof socket.address().address === 'undefined') {\n                const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n                once(socket, 'lookup', cancelTimeout);\n            }\n            if (typeof delays.connect !== 'undefined') {\n                const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n                if (hasPath) {\n                    once(socket, 'connect', timeConnect());\n                }\n                else {\n                    once(socket, 'lookup', (error) => {\n                        if (error === null) {\n                            once(socket, 'connect', timeConnect());\n                        }\n                    });\n                }\n            }\n            if (typeof delays.secureConnect !== 'undefined' && options.protocol === 'https:') {\n                once(socket, 'connect', () => {\n                    const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n                    once(socket, 'secureConnect', cancelTimeout);\n                });\n            }\n        }\n        if (typeof delays.send !== 'undefined') {\n            const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n            /* istanbul ignore next: hard to test */\n            if (socket.connecting) {\n                once(socket, 'connect', () => {\n                    once(request, 'upload-complete', timeRequest());\n                });\n            }\n            else {\n                once(request, 'upload-complete', timeRequest());\n            }\n        }\n    });\n    if (typeof delays.response !== 'undefined') {\n        once(request, 'upload-complete', () => {\n            const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n            once(request, 'response', cancelTimeout);\n        });\n    }\n    return cancelTimeouts;\n};\n"]},"metadata":{},"sourceType":"script"}